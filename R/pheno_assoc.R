################## 
# Author: Vinicius Henrique da Silva 
# Script description: Functions related to CNV-GWAS
# Date: July 20, 2018 
# Code: CNVASSOPACK002
################## 

#' Run the CNV-GWAS 
#'
#' Wraps all the necessary functions to run a CNV-GWAS using the output of 
#' \code{\link{setupCnvGWAS}} function
#'  
#' (i) Produces the GDS file containing the genotype information  (if produce.gds == TRUE),
#' (ii) Produces the requested inputs for a PLINK analysis, 
#' (iii) run a CNV-GWAS analysis using linear model implemented in PLINK 
#' (http://zzz.bwh.harvard.edu/plink/gvar.shtml), and 
#' (iv) export a QQ-plot displaying the adjusted p-values. 
#' In this release only the p-value for the copy number is available  (i.e. 'P(CNP)'). 
#'   
#' @param phen.info Returned by \code{\link{setupCnvGWAS}}
#' @param n.cor Number of cores to be used
#' @param min.sim Minimum CNV genotype distribuition similarity among subsequent
#' probes. Default is 0.95 (i.e. 95\%)
#' @param freq.cn Minimum CNV frequency where 1 (i.e. 100\%), or all samples 
#' deviating from diploid state. Default 0.01 (i.e. 1\%)
#' @param snp.matrix Only FALSE implemented - If TRUE B allele frequencies (BAF)
#' would be used to reconstruct CNV-SNP genotypes
#' @param method.m.test Correction for multiple tests to be used. FDR is default, 
#' see \code{\link{p.adjust}} for other methods.
#' @param lo.phe The phenotype to be analyzed in the PhenInfo$phenotypesSam data-frame 
#' @param chr.code.name A data-frame with the integer name in the first column 
#' and the original name for each chromosome  
#' @param genotype.nodes Expression data type. Nodes with CNV genotypes to be 
#' produced in the gds file. 
#' @param coding.translate For 'CNVgenotypeSNPlike'. If NULL or unrecognized 
#' string use only biallelic CNVs. If 'all' code multiallelic CNVs as 0 
#' for loss; 1 for 2n and 2 for gain.
#' @param path.files Folder containing the input CNV files used for the CNV 
#' calling (i.e. one text file with 5 collumns for each sample). Columns should 
#' contain (i) probe name, (ii) Chromosome, (iii) Position, (iv) LRR, and (v) BAF.
#' @param list.of.files Data-frame with two columns where the (i) is the file 
#' name with signals and (ii) is the correspondent name of the sample in the gds file
#' @param produce.gds logical. If TRUE produce a new gds, if FALSE use gds previously created   
#' @param run.lrr If TRUE use LRR values instead absolute copy numbers in the association
#' @param assign.probe \sQuote{min.pvalue} or \sQuote{high.freq} to represent the CNV segment
#' @param correct.inflation logical. Estimate lambda from raw p-values and correct for genomic inflation.
#' Use with argument \code{method.m.test} to generate strict p-values. 
#' @param both.up.down Check for CNV genotype similarity in both directions. 
#' Default is FALSE (i.e. only downstream)
#' @param model Linear mixed model to fit (without the CNV). Use \code{\link{formula}}
#' @param method.to.run GWAS method. Linear regression with PLINK is \sQuote{plink} and 
#' linear mixed model is \sQuote{lmm} 
#' @param model.cnv.interactions 'CNV' or 'LRR' effect to be compared with the fitted model without CNV effect
#' (using ANOVA)
#' @param use.grm Genomic relationship matrix which is "SNP.based", "CNV.based" or 
#' NULL to use pedigree instead (if available).
#' @param use.pca If PCA analysis should be used from external SNP.gds or automatically created
#' within the CNV.gds. Options are "SNP.based", "CNV.based" or 
#' NULL to use pedigree instead (if available).
#' @param lrr.to.use Use a median of LRR across de probes overlapping the CNV segment instead individual
#' LRR probe values
#' @param simulation Numeric or NULL. If numeric, simulated phenotypes will be used. The number
#' will define the number of permutation (i.e. if simualtion = 1000, the analysis will be performed
#' 1000 times with random phenotypes). The random phenotypes have the same standard deviation and mean
#' of the real phenotype defined in the model. This option is only available if \sQuote{method.to.run}
#' is 'lmm', otherwise NULL should be set.
#' @param verbose Show progress in the analysis
#' @return CNV segments, representative probes and their respective p-values
#' @author Vinicius Henrique da Silva <vinicius.dasilva@@wur.nl>
#' @seealso \code{link{setupCnvGWAS}} to setup files needed for the CNV-GWAS.
#' @references da Silva et al. (2016) Genome-wide detection of CNVs and their 
#' association with meat tenderness in Nelore cattle. PLoS One, 11(6):e0157711.
#'
#' @examples
#' 
#' # Load phenotype-CNV information
#' data.dir <- system.file("extdata", package="cnvAnalyzeR")
#' 
#' phen.loc <- file.path(data.dir, "Pheno.txt")
#' cnv.out.loc <- file.path(data.dir, "CNVOut.txt")
#' map.loc <- file.path(data.dir, "MapPenn.txt")
#'
#' phen.info <- setupCnvGWAS('Example', phen.loc, cnv.out.loc, map.loc)
#' 
#' # Define chr correspondence to numeric, if necessary
#' df <- '16 1A
#' 25 4A
#' 29 25LG1
#' 30 25LG2
#' 31 LGE22'
#' 
#' chr.code.name <- read.table(text=df, header=FALSE)
#' segs.pvalue.gr <- cnvGWAS(phen.info, chr.code.name=chr.code.name)
#'  
#' @export

cnvGWAS <- function(phen.info, n.cor = 1, min.sim = 0.95, freq.cn = 0.01, snp.matrix = FALSE, 
                    method.m.test = "fdr", lo.phe = 1, chr.code.name = NULL, genotype.nodes = c("CNVGenotype", "CNVgenotypeSNPlike"), 
                    coding.translate = "all", path.files = NULL, list.of.files = NULL, produce.gds = TRUE, 
                    run.lrr = FALSE, assign.probe = "min.pvalue", correct.inflation = FALSE, both.up.down = FALSE, 
                    model=NULL, method.to.run="plink", model.cnv.interactions="CNVx", verbose = FALSE,
                    snp.gds=NULL, use.grm=NULL, use.pca=NULL, norm.lrr=TRUE, max.lrr=0.9, min.lrr=0.1,
                    lrr.to.use="standard", simulation=NULL, list.simulation=NULL) {
  
  if(!is.null(simulation)){
    stopifnot(is.numeric(simulation))
    stopifnot(method.to.run=="lmm")
  }
  
  phenotypesSam <- phen.info$phenotypesSam
  phenotypesSamX <- phenotypesSam[, c(1, (lo.phe + 1))]
  phenotypesSamX <- stats::na.omit(phenotypesSamX)
  all.paths <- phen.info$all.paths
  dup.samples <- phen.info$duplicated.samples
  
  # Produce the GDS for a given phenotype
  if (produce.gds) {
    if (verbose) 
      message("Produce the GDS for a given phenotype")
    probes.cnv.gr <- prodGdsCnv(phen.info = phen.info, freq.cn = freq.cn, snp.matrix = snp.matrix, 
                                lo.phe = lo.phe, chr.code.name = chr.code.name, genotype.nodes = genotype.nodes, 
                                coding.translate = coding.translate)
  } else {
    if (verbose) 
      message("Using existent gds file")
    probes.cnv.gr <- .prodProbes(phen.info, lo.phe, freq.cn)
  }
    
  # Produce CNV segments
  if (verbose) 
    message("Produce CNV segments")
  all.segs.gr <- .prodCNVseg(all.paths, probes.cnv.gr, min.sim, both.up.down)
  
  if (method.to.run=="plink"){
  # Produce PLINK map 
  if (verbose) 
    message("Produce PLINK map")
  .prodPLINKmap(all.paths)
  
  # Produce gvar to use as PLINK input
  if (verbose) 
    message("Produce gvar to use as PLINK input")
  .prodPLINKgvar(all.paths, n.cor, snp.matrix, run.lrr)
  
  # Produce fam (phenotype) to use as PLINK input
  if (verbose) 
    message("Produce fam (phenotype) to use as PLINK input")
  .prodPLINKfam(all.paths)
  
  # Run PLINK
  if (verbose) 
    message("Run PLINK")
  suppressMessages(.runPLINK(all.paths))
  
  # Associate SNPs with CNV segments
  if (verbose) 
    message("Associate SNPs with CNV segments")
  segs.pvalue.gr <- .assoPrCNV(all.paths, all.segs.gr, phenotypesSamX, method.m.test, 
                               probes.cnv.gr, assign.probe, correct.inflation = correct.inflation)
  
  }else if (method.to.run=="lmm"){
  ### Run LMM if model exists
  if(!is.null(model)){
  
  if(is.null(simulation) || simulation == 0){
  segs.pvalue.gr <- lmmCNV(all.paths=all.paths, all.segs.gr=all.segs.gr, phen.info=phen.info, 
                           method.m.test=method.m.test, model=model, probes.cnv.gr=probes.cnv.gr, 
                           assign.probe=assign.probe, correct.inflation=correct.inflation,
                           phenotypesSamX=phenotypesSamX, n.cor=n.cor, model.cnv.interactions=model.cnv.interactions,
                           run.lrr=run.lrr, verbose=verbose, snp.gds=snp.gds, use.grm=use.grm,
                           use.pca=use.pca, norm.lrr=norm.lrr, max.lrr=max.lrr, min.lrr=min.lrr,
                           lrr.to.use=lrr.to.use)
  }else{
  ## Simulation with random phenotypes ## use mean and sd of real phenotypes
  segs.pvalue.gr.all <- GRangesList()  
  
  ### Load CNV genotypes
  cnv.gds <- file.path(all.paths[1], "CNV.gds")
  genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE, readonly = FALSE)
  
  if(is.null(list.simulation)){
  for(lop.sim in seq_len(simulation)){
  if(lop.sim==1){
  phen.name.in.model <- as.character(model[2])
  pedigree.x <- phen.info$pedigree
  pedigree.x.back <- pedigree.x
  phen.values <- pedigree.x[,which(colnames(pedigree.x) == phen.name.in.model)]
  sd.phen <- sd(phen.values, na.rm=TRUE)
  mean.phen <- mean(phen.values, na.rm=TRUE)
  num.na <- sum(is.na(phen.values))
  known.phen <- length(phen.values)-num.na
  na.to.bind <- rep(NA, num.na)}
  
  sim.phen <- rnorm(known.phen, mean=mean.phen, sd=sd.phen)
  sim.phen <- c(sim.phen, na.to.bind)
  sim.phen <- sample(sim.phen)
  pedigree.x[,which(colnames(pedigree.x) == phen.name.in.model)] <- sim.phen
  list.simulation[[lop.sim]] <- pedigree.x
  }
  }
  
  #}else{
  #pedigree.x <- list.simulation[[lop.sim]]
  #phen.info$pedigree <- pedigree.x ## Attach simulated phenotypes
  #}
  
  
  #segs.pvalue.gr.all[[lop.sim]] <- lmmCNV(all.paths=all.paths, all.segs.gr=all.segs.gr, phen.info=phen.info, 
  #                           method.m.test=method.m.test, model=model, probes.cnv.gr=probes.cnv.gr, 
  #                           assign.probe=assign.probe, correct.inflation=correct.inflation,
  #                           phenotypesSamX=phenotypesSamX, n.cor=1, model.cnv.interactions=model.cnv.interactions,
  #                           run.lrr=run.lrr, verbose=verbose, snp.gds=snp.gds, use.grm=use.grm,
  #                           use.pca=use.pca, norm.lrr=norm.lrr, max.lrr, min.lrr,
  #                           lrr.to.use=lrr.to.use, simulation=simulation, genofile=genofile)
  
  if (rappdirs:::get_os() == "unix" | rappdirs:::get_os() == "mac") {
    multicoreParam <- BiocParallel::MulticoreParam(workers = n.cor)
    segs.pvalue.gr.all <- BiocParallel::bplapply(1:simulation, lmmCNV, BPPARAM = multicoreParam, 
                           all.paths=all.paths, all.segs.gr=all.segs.gr, phen.info=phen.info, 
                                                      method.m.test=method.m.test, model=model, probes.cnv.gr=probes.cnv.gr, 
                                                      assign.probe=assign.probe, correct.inflation=correct.inflation,
                                                      phenotypesSamX=phenotypesSamX, n.cor=1, model.cnv.interactions=model.cnv.interactions,
                                                      run.lrr=run.lrr, verbose=verbose, snp.gds=snp.gds, use.grm=use.grm,
                                                      use.pca=use.pca, norm.lrr=norm.lrr, max.lrr, min.lrr,
                                                      lrr.to.use=lrr.to.use, simulation=simulation, genofile=genofile,
                                                      list.simulation=list.simulation)
  }
  
  if (rappdirs:::get_os() == "win") {
    param <- BiocParallel::SnowParam(workers = 1, type = "SOCK")
    segs.pvalue.gr.all <- BiocParallel::bplapply(1:simulation, lmmCNV, BPPARAM = multicoreParam, 
                           all.paths=all.paths, all.segs.gr=all.segs.gr, phen.info=phen.info, 
                           method.m.test=method.m.test, model=model, probes.cnv.gr=probes.cnv.gr, 
                           assign.probe=assign.probe, correct.inflation=correct.inflation,
                           phenotypesSamX=phenotypesSamX, n.cor=1, model.cnv.interactions=model.cnv.interactions,
                           run.lrr=run.lrr, verbose=verbose, snp.gds=snp.gds, use.grm=use.grm,
                           use.pca=use.pca, norm.lrr=norm.lrr, max.lrr, min.lrr,
                           lrr.to.use=lrr.to.use, simulation=simulation, genofile=genofile,
                           list.simulation=list.simulation)
    
  }
  
  #if (verbose) 
  #  message(paste("Simulation of phenotypes", lop.sim, "of", simulation))
  
  #}
  SNPRelate::snpgdsClose(genofile)
  }
  
  }else{
  message("No model specified for the LMM run")
                           }
  }else{
    message("Only plink and lmm options available")
  }
  
  if(is.null(simulation)){
  # Plot the QQ-plot of the analysis
  if (verbose) 
    message("Plot the QQ-plot of the analysis")
  
  uphen <- unique(segs.pvalue.gr$Phenotype)
  qq.plot.pdf <- paste0(uphen, "-LRR-", run.lrr, "QQ-PLOT.pdf")
  qq.plot.pdf <- file.path(all.paths[3], qq.plot.pdf)
  pdf(qq.plot.pdf)
  print(qqunifPlot(segs.pvalue.gr$MinPvalueAdjusted, 
                    auto.key = list(corner = c(0.95, 0.05))))
  invisible(dev.off())
  
  # Reconvert the chrs to original names if applicable
  if (!is.null(chr.code.name)) {
    cnv.gds <- file.path(all.paths[1], "CNV.gds")
    genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE, readonly = FALSE)
    chr.code.name <- gdsfmt::index.gdsn(genofile, "Chr.names")
    chr.code.name <- gdsfmt::read.gdsn(chr.code.name)
    
    segs.pvalue <- data.frame(segs.pvalue.gr)
    segs.pvalue <- segs.pvalue[, !(names(segs.pvalue) %in% "strand")]
    
    for (lopN in seq_len(nrow(chr.code.name))) 
      segs.pvalue$seqnames <- gsub(chr.code.name[lopN, 1], 
                                   chr.code.name[lopN, 2], 
                                   segs.pvalue$seqnames)
    
    segs.pvalue.gr <- GenomicRanges::makeGRangesFromDataFrame(segs.pvalue, keep.extra.columns = TRUE)
    SNPRelate::snpgdsClose(genofile)
  }
  
  segs.pvalue.gr <- segs.pvalue.gr[order(segs.pvalue.gr$MinPvalue)]
  return(segs.pvalue.gr)
  
  }else{
    for(lop.segs in seq_len(length(segs.pvalue.gr.all))){
    segs.pvalue.gr <- segs.pvalue.gr.all[[lop.segs]]
    # Reconvert the chrs to original names if applicable
    if (!is.null(chr.code.name)) {
      cnv.gds <- file.path(all.paths[1], "CNV.gds")
      genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE, readonly = FALSE)
      chr.code.name <- gdsfmt::index.gdsn(genofile, "Chr.names")
      chr.code.name <- gdsfmt::read.gdsn(chr.code.name)
      
      segs.pvalue <- data.frame(segs.pvalue.gr)
      segs.pvalue <- segs.pvalue[, !(names(segs.pvalue) %in% "strand")]
      
      for (lopN in seq_len(nrow(chr.code.name))) 
        segs.pvalue$seqnames <- gsub(chr.code.name[lopN, 1], 
                                     chr.code.name[lopN, 2], 
                                     segs.pvalue$seqnames)
      
      segs.pvalue.gr <- GenomicRanges::makeGRangesFromDataFrame(segs.pvalue, keep.extra.columns = TRUE)
      SNPRelate::snpgdsClose(genofile)
    }
    
    segs.pvalue.gr <- segs.pvalue.gr[order(segs.pvalue.gr$MinPvalue)]  
    segs.pvalue.gr.all[[lop.segs]] <- segs.pvalue.gr
    }
    return(segs.pvalue.gr.all)
  }
}


#' Setup the folders and files to run CNV-GWAS analysis
#'
#' This function creates the (i) necessary folders in disk to perform downstream 
#' analysis on CNV genome-wide association and (ii) import the necessary input 
#' files (i.e. phenotypes, probe map and CNV list) from other locations in disk.
#' 
#' The user can import several phenotypes at once. All information will be 
#' stored in the list returned by this function. 
#' The user should be aware although several phenotypes can be imported, the 
#' \code{\link{cnvGWAS}} or \code{\link{prodGdsCnv}} functions will handle only 
#' one phenotype per run. 
#' 
#' @param name String with a project code or name (e.g. 'Project1')
#' @param phen.loc Path/paths to the tab separated text file cointaining phenotype 
#' and sample info. When using more than one population, for populations without
#' phenotypes include the string 'INEXISTENT' instead the path for a file.
#' @param cnv.out.loc Path(s) to the CNV analysis output (i.e. PennCNV output, 
#' SNP-chip general format or sequencing general format)
#' @param map.loc Path to the probe map (e.g. used in PennCNV analysis). Column 
#' names containing probe name, chromosome and coordinate must be named as: Name, 
#' Chr and Position. Tab delimited. If NULL, artificial probes will be generated 
#' based on the CNV breakpoints.
#' @param folder Choose manually the project folder (i.e. root folder with all project files). 
#' Otherwise, user-specific data dir will be used automatically.  
#' @param pops.names Indicate the name of the populations, if using more than one.
#' @param pedigree.loc Path to the pedigree information (i.e. sample sire and dam). One merged file
#' for multiple populations.
#' @param snp.gds External GDS file with SNP genotypes and two additional nodes (optional): PCA and 
#' genomic relationship matrix (GRM) nodes. 
#' @param n.cor Number of cores
#' @return List \sQuote{phen.info} with \sQuote{samplesPhen}, \sQuote{phenotypes}, 
#' \sQuote{phenotypesdf}, \sQuote{phenotypesSam}, \sQuote{FamID}, \sQuote{SexIds}, 
#' \sQuote{pops.names} (if more than one population) and \sQuote{all.paths}
#' @author Vinicius Henrique da Silva <vinicius.dasilva@@wur.nl>
#' @examples
#' 
#' data.dir <- system.file("extdata", package="cnvAnalyzeR")
#' 
#' phen.loc <- file.path(data.dir, "Pheno.txt")
#' cnv.out.loc <- file.path(data.dir, "CNVOut.txt")
#' map.loc <- file.path(data.dir, "MapPenn.txt")
#'
#' phen.info <- setupCnvGWAS('Example', phen.loc, cnv.out.loc, map.loc)
#' 
#' 
#' @export

setupCnvGWAS <- function(name, phen.loc, cnv.out.loc, map.loc = NULL, folder = NULL, 
                         pops.names = NULL, pedigree.loc=NULL, snp.gds=NULL, n.cor = 1) {
  
  ## Create the folder structure for all subsequent analysis
  all.paths <- .createFolderTree(name, folder)
  
  if(!is.null(snp.gds)){
    file.copy(snp.gds, file.path(all.paths[1], "/SNP.gds"), overwrite = TRUE)
  }
  
  ## Only one population
  if (length(phen.loc) == 1 && length(cnv.out.loc) == 1) {
    ## Import the phenotype and sample info from external folder
    file.copy(phen.loc, file.path(all.paths[1], "/PhenoPop1.txt"), overwrite = TRUE)
    ## Import the PennCNV output from external folder
    file.copy(cnv.out.loc, file.path(all.paths[1], "/CNVOut.txt"), overwrite = TRUE)
    file.copy(cnv.out.loc, file.path(all.paths[1], "/CNVOutPop1.txt"), overwrite = TRUE)
    pheno.file <- "PhenoPop1.txt"
    cnv.file <- "CNVOut.txt"
  }
  
  ## Multiple populations
  if (length(phen.loc) != length(cnv.out.loc)) 
    stop("phen.loc and cnv.out.loc should have the same length. Use the string INEXISTENT if phenotypes are missing")
  
  if (length(phen.loc) > 1 && length(cnv.out.loc) > 1) {
    
    pheno.file.all <- NULL
    cnv.file.all <- NULL
    
    for (npop in seq_along(phen.loc)) {
      pheno.file <- paste0("/PhenoPop", npop, ".txt")
      pheno.file.all[[npop]] <- pheno.file
      cnv.file <- paste0("/CNVOutPop", npop, ".txt")
      cnv.file.all[[npop]] <- cnv.file
      
      if (phen.loc[npop] == "INEXISTENT") {
        write.table(c("INEXISTENT"), file.path(all.paths[1], pheno.file), 
                    quote = FALSE, col.names = FALSE, row.names = FALSE)
      } else {
        file.copy(phen.loc[npop], file.path(all.paths[1], pheno.file), overwrite = TRUE)
      }
      file.copy(cnv.out.loc[npop], file.path(all.paths[1], cnv.file), overwrite = TRUE)
    }
  }
  
  ## Write phenotype names and merge CNV file for multiple populations
  if (length(phen.loc) > 1 && length(cnv.out.loc) > 1) {
    pheno.file <- unlist(pheno.file.all)
    all.cnvs <- lapply(cnv.file.all, .loadToMergeCNV, cnv.path = all.paths[1])
    all.cnvs <- data.table::rbindlist(all.cnvs)
    all.cnvs <- as.data.frame(all.cnvs)
    write.table(all.cnvs, file.path(all.paths[1], "CNVOut.txt"), sep = "\t", 
                col.names = TRUE, row.names = FALSE)
  }
  
  ## Call the phenotypes
  file.nam <- pheno.file
  phen.info <- .loadPhen(file.nam, all.paths, pops.names = pops.names, n.cor)
  dup.samples <- phen.info$duplicated.samples
  
  if (is.null(map.loc)) {
    ## Import the probe map from external folder
    cnvs <- read.table(file.path(all.paths[1], "CNVOut.txt"), sep = "", header = F)  ### CNV table 
    CNVs <- .checkConvertCNVs(cnvs, all.paths, dup.samples, n.cor)
    message(paste0("Number of CNVs", nrow(CNVs)))
    
    CGr <- GenomicRanges::makeGRangesFromDataFrame(CNVs)
    
  } else {
    if (length(map.loc) > 1) 
      stop("The map should be unique. If multiple populations with different probe map use map.loc=NULL")
    file.copy(map.loc, file.path(all.paths[1], "MapPenn.txt"), overwrite = TRUE)
  }
  
  plink.dir <- dir(all.paths[2], pattern = "plink-1*")
  plink.bin <- file.path(all.paths[2], plink.dir, "plink")
  
  if (length(plink.bin)==0){
    got.plink <- .getPLINK(all.paths[2])
  }else{
    if (!file.exists(plink.bin)) {
      got.plink <- .getPLINK(all.paths[2])
      if (!got.plink) 
        stop("PLINK setup failed")
    }
  }
  all.paths[2] <- dirname(plink.bin)
  
  phen.info$all.paths <- all.paths
  phen.info$phenotypesSam$samplesPhen <- as.character(phen.info$phenotypesSam$samplesPhen)
  
  ## Import pedigree information
  if(!is.null(pedigree.loc)){
  pedigree <- .loadPedi(all.paths, pedigree.loc)}
  
  phen.info$pedigree <- as.data.frame(pedigree)
  
  return(phen.info)
}


#' Produce CNV-GDS for the phenotyped samples
#'
#' Function to produce the GDS file in a probe-wise fashion for CNV genotypes. 
#' The GDS file which is produced also incorporates one phenotype to be analyzed. 
#' If several phenotypes are enclosed in the \sQuote{phen.info} object, the user 
#' may specify the phenotype to be analyzed with the \sQuote{lo.phe} parameter. 
#' Only diploid chromosomes should be included.  
#'
#' @param phen.info Returned by \code{setupCnvGWAS}
#' @param freq.cn Minimum frequency. Default is 0.01 (i.e. 1\%)
#' @param snp.matrix Only FALSE implemented. If TRUE, B allele frequencies (BAF) 
#' and SNP genotypes would be used to reconstruct CNV-SNP genotypes - under development
#' @param lo.phe The phenotype to be analyzed in the PhenInfo$phenotypesSam dataframe 
#' @param chr.code.name A data-frame with the integer name in the first column 
#' and the original name in the second for each chromosome previously converted to numeric
#' @param genotype.nodes Nodes with CNV genotypes to be produced in the gds file. 
#' Use 'CNVGenotype' for dosage-like genotypes (i.e. from 0 to Inf). 
#' Use 'CNVgenotypeSNPlike' alonside for SNP-like CNV genotype in a separated 
#' node (i.e.  '0, 1, 2, 3, 4' as '0/0, 0/1, 1/1, 1/2, 2/2').
#' @param coding.translate For 'CNVgenotypeSNPlike'. If NULL or unrecognized 
#' string use only biallelic CNVs. If 'all' code multiallelic CNVs as 0 for loss; 
#' 1 for 2n and 2 for gain. 
#' @param n.cor Number of cores
#' @return probes.cnv.gr Object with information about all probes to be used in 
#' the downstream CNV-GWAS. Only numeric chromosomes
#' @author Vinicius Henrique da Silva <vinicius.dasilva@@wur.nl>
#' @examples
#' 
#' # Load phenotype-CNV information
#' data.dir <- system.file("extdata", package="cnvAnalyzeR")
#' 
#' phen.loc <- file.path(data.dir, "Pheno.txt")
#' cnv.out.loc <- file.path(data.dir, "CNVOut.txt")
#' map.loc <- file.path(data.dir, "MapPenn.txt")
#'
#' phen.info <- setupCnvGWAS('Example', phen.loc, cnv.out.loc, map.loc)
#'
#' # Construct the data-frame with integer and original chromosome names 
#'  
#' # Define chr correspondence to numeric, if necessary
#' df <- '16 1A
#' 25 4A
#' 29 25LG1
#' 30 25LG2
#' 31 LGE22'
#' 
#' chr.code.name <- read.table(text=df, header=FALSE)
#' probes.cnv.gr <- prodGdsCnv(phen.info, chr.code.name=chr.code.name)
#' 
#'@export

prodGdsCnv <- function(phen.info, freq.cn = 0.01, snp.matrix = FALSE, lo.phe = 1,
                       chr.code.name = NULL, genotype.nodes = c("CNVGenotype", "CNVgenotypeSNPlike"), 
                       coding.translate = NULL, n.cor = 1) 
{
  phenotypesSam <- phen.info$phenotypesSam
  samplesPhen <- phen.info$samplesPhen
  FamID <- phen.info$FamID
  SexIds <- phen.info$SexIds
  all.paths <- phen.info$all.paths
  phenotypesSamX <- phenotypesSam[, c(1, (lo.phe + 1))]
  dup.samples <- phen.info$duplicated.samples
  
  # Import CNVs to data-frame
  cnv.table <- file.path(all.paths[1], "CNVOut.txt")
  cnvs <- data.table::fread(cnv.table, sep = "\t", header = FALSE)
  CNVs <- .checkConvertCNVs(cnvs, all.paths, dup.samples, n.cor)
  message(paste0("Number of CNVs", nrow(CNVs)))
  
  # Check if the chromosomes are numeric
  chr.names <- CNVs$chr
  chr.names <- gsub("chr", "", chr.names)
  
  if (any(is.na(chr.names))) stop("Chromosome names should be integers")
  
  CNVsGr <- GenomicRanges::makeGRangesFromDataFrame(CNVs, keep.extra.columns = TRUE)
  # Subset CNVs in phenotyped samples
  CNVsGr <- CNVsGr[CNVsGr$V5 %in% samplesPhen]
    
  # Import SNP map to data-frame
  map.file <- file.path(all.paths[1], "MapPenn.txt")
  probes <- data.table::fread(map.file, header = TRUE, sep = "\t")
  probes <- as.data.frame(probes)
  probes <- probes[stats::complete.cases(probes), ]
  probesGr <- GenomicRanges::makeGRangesFromDataFrame(probes, seqnames.field = "Chr", 
                                                      start.field = "Position", end.field = "Position", keep.extra.columns = TRUE)
  
  all.samples <- unique(CNVsGr$V5)
  
  # Select probes within CNVs
  probesCNV <- IRanges::subsetByOverlaps(probesGr, CNVsGr)$Name
  probesCNV <- unique(unlist(probesCNV))
  probes.cnv.gr <- probesGr[probesGr$Name %in% probesCNV]
  
  # Estimate the frequency per probe
  counts <- GenomicRanges::countOverlaps(probes.cnv.gr, CNVsGr)
  probes.cnv.gr$freq <- unname(counts)
  
  # Subset by frequency
  NumSam <- freq.cn * length(all.samples)
  probes.cnv.gr <- probes.cnv.gr[probes.cnv.gr$freq >= NumSam]
  
  # Order the probes
  probes.cnv.gr <- GenomeInfoDb::sortSeqlevels(probes.cnv.gr)
  probes.cnv.gr <- GenomicRanges::sort(probes.cnv.gr)
  
  probes.cnv.gr$snp.id <- seq_along(probes.cnv.gr)
  
  # SNP genotype matrix not available
  if (!snp.matrix) CNVBiMa <- matrix(2, nrow = length(probes.cnv.gr), ncol = length(all.samples)) 
  else stop("Option to consider SNP matrix is not implemented yet")
  # TODO: SNP genotype matrix available 
  # CHECK IF WE HAVE THE SAME SAMPLES -
  # INCLUDE NA FOR SAMPLES WITH ONLY ONE GENOTYPE TYPE? (i.e CNV or SNP)
  
  # Create a GDS with chr and SNP names to numeric
  cnv.gds <- file.path(all.paths[1], "CNV.gds")
  SNPRelate::snpgdsCreateGeno(cnv.gds, genmat = CNVBiMa, sample.id = all.samples, 
                              snp.id = as.character(probes.cnv.gr$snp.id), snp.rs.id = probes.cnv.gr$Name, 
                              snp.chromosome = as.character(GenomicRanges::seqnames(probes.cnv.gr)), 
                              snp.position = GenomicRanges::start(probes.cnv.gr))
  
  
  #genotype.nodes <- match.arg(genotype.nodes)    
  if ("CNVGenotype" %in% genotype.nodes) {
    # Replace genotype matrix with CNV genotypes
    genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE, readonly = FALSE)
    n <- gdsfmt::add.gdsn(genofile, "CNVgenotype", CNVBiMa, replace = TRUE)
    
    if (rappdirs:::get_os() == "unix" | rappdirs:::get_os() == "mac") {
      multicoreParam <- BiocParallel::SnowParam(workers = 1, type = "SOCK")
      BiocParallel::bplapply(seq_along(all.samples), .writeProbesCNV, BPPARAM = multicoreParam, 
                             all.samples = all.samples, genofile = genofile, CNVsGr = CNVsGr, 
                             probes.cnv.gr = probes.cnv.gr, n = n)
    }
    
    if (rappdirs:::get_os() == "win") {
      param <- BiocParallel::SnowParam(workers = 1, type = "SOCK")
      BiocParallel::bplapply(seq_along(all.samples), .writeProbesCNV, BPPARAM = param, 
                             all.samples = all.samples, genofile = genofile, CNVsGr = CNVsGr, 
                             probes.cnv.gr = probes.cnv.gr, n = n)
    }
    
    testit(15)  ## Wait to make sure that gds is writen in parallel
    SNPRelate::snpgdsClose(genofile)
  }
  
  if ("CNVgenotypeSNPlike" %in% genotype.nodes){
    # CNVgenotypeSNPlike
    genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE, 
                                      readonly = FALSE)
    
    CNVBiMaCN <- matrix(2, nrow = length(probes.cnv.gr), ncol = length(all.samples))
    
    n <- gdsfmt::add.gdsn(genofile, "CNVgenotypeSNPlike", CNVBiMaCN, replace = TRUE)
    
    #Define the chunks of SNPs to import chunk
    chunk <- seq(from = 1, to = length(probes.cnv.gr), by = length(probes.cnv.gr))  ## No chunk
    
    if (chunk[length(chunk)] != length(probes.cnv.gr)) {
      chunk[length(chunk) + 1] <- length(probes.cnv.gr)
    }
    
    if (rappdirs:::get_os() == "unix" | rappdirs:::get_os() == "mac") {
      multicoreParam <- BiocParallel::MulticoreParam(workers = 1)
      BiocParallel::bplapply(1:(length(chunk) - 1), .recodeCNVgenotype, BPPARAM = multicoreParam, 
                             genofile = genofile, all.samples = all.samples, n = n, chunk = chunk, 
                             coding.translate = coding.translate)
    }
    
    if (rappdirs:::get_os() == "win") {
      param <- BiocParallel::SnowParam(workers = 1, type = "SOCK")
      BiocParallel::bplapply(1:(length(chunk) - 1), .recodeCNVgenotype, BPPARAM = param, 
                             genofile = genofile, all.samples = all.samples, n = n, chunk = chunk, 
                             coding.translate = coding.translate)
    }
    testit(15)  ## Wait to make sure that gds is writen in parallel
    gdsfmt::closefn.gds(genofile)
    
    
  }
  
  # Include the phenotype 'lo' in the GDS
  genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE, readonly = FALSE)
  phenotypesSamX <- phenotypesSamX[match(all.samples, phenotypesSamX$samplesPhen),] 
  phenotypesSamX[,2] <- suppressWarnings(as.numeric(as.character(phenotypesSamX[,2])))
  if(!is.numeric(phenotypesSamX[,2])){
    stop("Phenotype is not numeric. The analysis requires a quantitative phenotype.")
  }
  gdsfmt::add.gdsn(genofile, name = "phenotype", val = phenotypesSamX, replace = TRUE)
  FamID <- FamID[match(all.samples, FamID$samplesPhen), ]
  gdsfmt::add.gdsn(genofile, name = "FamID", val = as.character(FamID[, 2]), replace = TRUE, 
                   storage = "string")
  FamID <- SexIds[match(all.samples, SexIds$samplesPhen), ]
  gdsfmt::add.gdsn(genofile, name = "Sex", val = as.character(SexIds[, 2]), replace = TRUE, 
                   storage = "string")
  
  # Include chr names if needed
  if (!is.null(chr.code.name))
    gdsfmt::add.gdsn(genofile, name = "Chr.names", val = chr.code.name, replace = TRUE)
  
  if (!is.null(phen.info$pops.names))
    gdsfmt::add.gdsn(genofile, name = "Pops.names", val = phen.info$pops.names, 
                     replace = TRUE)
  
  SNPRelate::snpgdsClose(genofile)
  testit(15)
  return(probes.cnv.gr)
}


#' Import LRR and BAF from text files used in the CNV analysis
#' 
#' This function imports the LRR/BAF values and create a node for each one in 
#' the GDS file at the working folder 'Inputs' created by the 
#' \code{\link{setupCnvGWAS}} function. Once imported, the LRR values can be 
#' used to perform a GWAS directly as an alternative to copy number dosage
#'
#' @param all.paths Object returned from \code{CreateFolderTree} function with 
#' the working folder tree 
#' @param path.files Folder containing the input CNV files used for the CNV 
#' calling (i.e. one text file with 5 collumns for each sample). Columns should 
#' contain (i) probe name, (ii) Chromosome, (iii) Position, (iv) LRR, and (v) BAF.
#' @param list.of.files Data-frame with two columns where the (i) is the file 
#' name with signals and (ii) is the correspondent name of the sample in the gds file
#' @param verbose Print the samples while importing
#' @author Vinicius Henrique da Silva <vinicius.dasilva@@wur.nl>
#' @examples
#' 
#' # Load phenotype-CNV information
#' data.dir <- system.file("extdata", package="cnvAnalyzeR")
#' 
#' phen.loc <- file.path(data.dir, "Pheno.txt")
#' cnv.out.loc <- file.path(data.dir, "CNVOut.txt")
#' map.loc <- file.path(data.dir, "MapPenn.txt")
#'
#' phen.info <- setupCnvGWAS('Example', phen.loc, cnv.out.loc, map.loc)
#'
#' # Extract path names
#' all.paths <- phen.info$all.paths
#' 
#' # List files to import LRR/BAF 
#' files <- list.files(data.dir, pattern = "\\.cnv.txt.adjusted$")
#' samples <- sub(".cnv.txt.adjusted$", "", files)
#' samples <- sub("^GT","", samples)
#' sample.files <- data.frame(file.names=files, sample.names=samples)
#'
#' # All missing samples will have LRR = '0' and BAF = '0.5' in all SNPs listed in the GDS file
#' importLRR_BAF(all.paths, data.dir, sample.files, verbose=FALSE)
#' 
#' # Read the GDS to check if the LRR/BAF nodes were added
#' cnv.gds <- file.path(all.paths[1], 'CNV.gds')    
#' genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork=TRUE, readonly=FALSE)
#' SNPRelate::snpgdsClose(genofile)
#' 
#' @export

importLRR_BAF <- function(all.paths, path.files, list.of.files, verbose=TRUE)
{
  cnv.gds <- file.path(all.paths[1], "CNV.gds")
  genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork=TRUE, readonly=FALSE)
  
  # Create file path for all text files
  file.paths <- file.path(path.files, list.of.files[, 1])
  gds.names <- list.of.files[, 2]
  list.filesLo <- data.frame(add = file.paths, gds = gds.names)
  
  snps.included <- gdsfmt::index.gdsn(genofile, "snp.rs.id")
  snps.included <- gdsfmt::read.gdsn(snps.included)
  snps.included <- as.character(snps.included)
  
  all.samples <- gdsfmt::index.gdsn(genofile, "sample.id")
  all.samples <- gdsfmt::read.gdsn(all.samples)
  all.samples <- as.character(all.samples)
  
  # Check if all files
  list.filesLo.back <- list.filesLo
  list.filesLo <- list.filesLo[list.filesLo$gds %in% all.samples, ]
  if(verbose){
    if (nrow(list.filesLo) != nrow(list.filesLo.back))
      warning("list.of.files has different length of the list of samples from gds")
  }
  
  LRR.matrix <- matrix(0, nrow = length(snps.included), ncol = length(all.samples))
  
  nLRR <- gdsfmt::add.gdsn(genofile, "LRR", LRR.matrix, replace = TRUE)
  gdsfmt::read.gdsn(nLRR)
  
  
  BAF.matrix <- matrix(0.5, nrow = length(snps.included), ncol = length(all.samples))
  
  nBAF <- gdsfmt::add.gdsn(genofile, "BAF", BAF.matrix, replace = TRUE)
  gdsfmt::read.gdsn(nBAF)
  
  if (rappdirs:::get_os() == "unix" | rappdirs:::get_os() == "mac") {
    param <- BiocParallel::SnowParam(workers = 1, type = "SOCK")
    if (verbose)
      message("Start parallel import of LRR/BAF values")
    
    BiocParallel::bplapply(seq_len(nrow(list.filesLo)), .freadImport, BPPARAM = param, 
                           list.filesLo = list.filesLo, genofile = genofile, all.samples = all.samples, 
                           nLRR = nLRR, nBAF = nBAF, snps.included = snps.included, verbose = verbose)
    
  }
  
  if (rappdirs:::get_os() == "win") {
    if (verbose) 
      message("Start parallel import of LRR/BAF values")
    
    param <- BiocParallel::SnowParam(workers = 1, type = "SOCK")
    BiocParallel::bplapply(seq_len(nrow(list.filesLo)), .freadImport, BPPARAM = param, 
                           list.filesLo = list.filesLo, genofile = genofile, all.samples = all.samples, 
                           nLRR = nLRR, nBAF = nBAF, snps.included = snps.included, verbose = verbose)
  }
  
  SNPRelate::snpgdsClose(genofile)
  
}

# Extract the CNV genotypes from the GDS file @param genofile is the loaded gds
# file @param snp.id is the SNP probe name to retrieve @param node.to.extract
# \sQuote{CNVgenotype} or \sQuote{CNVgenotypeSNPlike}. Default is
# \sQuote{CNVgenotype} @return CNV genotypes in a specific probe @author
# Vinicius Henrique da Silva <vinicius.dasilva@wur.nl>
.snpgdsGetGenoCNV <- function(genofile, snp.id, node.to.extract = "CNVgenotype") {
  
  map <- data.frame(snp.id = gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "snp.id")), 
                    chr = gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "snp.chromosome")), 
                    position = gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "snp.position")), 
                    probes = gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "snp.rs.id")), stringsAsFactors = FALSE)
  
  all.samples <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "sample.id"))
  
  snp.id <- as.numeric(as.character(map[map$probes == snp.id]))
  
  if (node.to.extract == "CNVgenotype") {
    gens <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "CNVgenotype"), start = c(snp.id, 
                                                                                     1), count = c(1, length(all.samples)))
  } else if (node.to.extract == "CNVgenotypeSNPlike") {
    gens <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "CNVgenotypeSNPlike"), 
                              start = c(snp.id, 1), count = c(1, length(all.samples)))
  } else {
    stop("Undefined node to extract CNV genotype")
  }
  return(gens)
}

# HELPER - Create the folder tree to keep necessary files during and after the
# analysis @param name String with a project code or name (e.g. 'Project1')
# @param folder Choose manually the project folder (i.e. path as the root
# folder). If NULL, a standard program folder will be chosen.  @return List with
# paths placed to store the files produced by subsequent analysis @examples
# all.paths <- createFolderTree('Project_name')
.createFolderTree <- function(name, folder = NULL) {
  
  # data dir
  if (is.null(folder)) 
    folder <- rappdirs::user_data_dir("cnvAnalyzeR")
  if (!file.exists(folder)) 
    dir.create(folder, recursive = TRUE)
  
  # project directory
  proj.dir <- file.path(folder, name)
  if (!file.exists(proj.dir)) 
    dir.create(proj.dir)
  
  # subdirs
  dirs <- c("Inputs", "PLINK", "Results")
  all.paths <- file.path(proj.dir, dirs)
  for (d in all.paths) if (!file.exists(d)) 
    dir.create(d)
  
  return(all.paths)
}

# HELPER - Download and test PLINK 1.07 @param all.paths Object returned from
# \code{CreateFolderTree} function with the working folder tree @param version
# PLINK version. Only 1.07 implemented @return boolean. Success (TRUE) or fail
# (FALSE) in running PLINK
.getPLINK <- function(plink.path, version = "1.07") {
  
  plink.url <- "http://zzz.bwh.harvard.edu/plink/dist/plink-"
  plink.url <- paste0(plink.url, version, "-")
  
  plink.file <- file.path(plink.path, "PLINK.zip")
  
  # get os-specific binary
  os <- rappdirs:::get_os()
  os <- switch(os, unix = "x86_64", mac = "mac-intel", win = "dos", os)
  
  plink.url <- paste0(plink.url, os, ".zip")
  
  # download & unzip
  download.file(plink.url, plink.file)
  unzip(plink.file, exdir = plink.path)
  
  # remove zip
  file.remove(plink.file)
  
  # path to plink binary
  plink.file <- dir(plink.path, pattern = "plink*")
  plink.path <- file.path(plink.path, plink.file, "plink")
  Sys.chmod(plink.path, mode = "755")
  
  suppressWarnings(res <- system2(plink.path, args = "--noweb", stdout = TRUE, 
                                  stderr = FALSE))
  
  res <- any(grepl(version, res))
  return(res)
}

# HELPER - Load phenotypes for each of the samples to be analyzed @param file.nam
# Name of the file to be imported @param pheno.path First item of the list
# returned by \code{CreateFolderTree} function @param pops.names Indicate the
# name of the populations. Only used if more than one population exists @param
# n.cor Number of cores @return List \sQuote{phen.info} with
# \sQuote{samplesPhen}, \sQuote{phenotypes}, \sQuote{phenotypesdf},
# \sQuote{phenotypesSam}, \sQuote{FamID} and \sQuote{SexIds} and
# \sQuote{pops.names} (if more than one population) @examples phen.info <-
# loadPhen('/home/.../Phen.txt') sapply(phen.info, class)

.loadPhen <- function(file.nam, all.paths, pops.names = NULL, n.cor = 1) {
  
  pheno.path <- all.paths[1]
  samplesPhen.all <- NULL
  phenotypes.all <- NULL
  phenotypesdf.all <- NULL
  phenotypesSam.all <- NULL
  FamID.all <- NULL
  SexIds.all <- NULL
  dup.samples <- NULL
  
  ## Prepare duplicated entries
  for (npop in seq_along(file.nam)) {
    dfN <- data.table::fread(file.path(pheno.path, file.nam[npop]))
    if (!all(names(dfN) == "INEXISTENT")) {
    dfN.back <- as.data.frame(dfN)
    dfN$sample.id <- with(dfN, make.unique(as.character(sample.id), sep = ".DupSampleExclu."))
    dfN <- as.data.frame(dfN)
    write.table(dfN, file.path(pheno.path, file.nam[npop]), col.names = TRUE, row.names = FALSE,
                quote=FALSE, sep = "\t")
    if(as.character(compare::compare(dfN$sample.id,dfN.back$sample.id,allowAll=TRUE))[1]==FALSE){
      message("Warning: Duplicated entries in sample.id")
      dup.samples <- dfN[grep(".DupSampleExclu.", dfN$sample.id),]$sample.id
    }
    }
  }
  
  for (npop in seq_along(file.nam)) {
    dfN <- data.table::fread(file.path(pheno.path, file.nam[npop]))
    if (all(names(dfN) == "INEXISTENT")) {
      ## Extract the sample names from CNV file instead
      cnv.file <- paste0("CNVOutPop", npop, ".txt")
      cnvs <- read.table(file.path(pheno.path, cnv.file), sep = "", header = FALSE)
      CNVs <- .checkConvertCNVs(cnvs, all.paths, dup.samples, n.cor)
      message(paste0("Number of CNVs", nrow(CNVs)))
      all.samples <- as.character(CNVs$V5)
      all.samples <- unique(all.samples)
      samplesPhen <- all.samples
      phenotypes <- phenotypes.all[[1]]
      phenotypesdf <- data.frame(rep("NA", length(all.samples)))
      colnames(phenotypesdf) <- phenotypes
      phenotypesSam <- cbind(all.samples, phenotypesdf)
      colnames(phenotypesSam)[1] <- "samplesPhen"
      FamID <- cbind(samplesPhen = as.character(phenotypesSam$samplesPhen), 
                     V2 = rep("NA", length(all.samples)))
      FamID <- as.data.frame(FamID)
      SexIds <- cbind(samplesPhen = as.character(phenotypesSam$samplesPhen), 
                      V2 = rep("NA", length(all.samples)))
      SexIds <- as.data.frame(SexIds)
      
    } else {
      all <- data.table::fread(file.path(pheno.path, file.nam[npop]), header = TRUE, 
                               sep = "\t")  ### Import phenotypes
      all <- as.data.frame(all)
      
      if (!all(colnames(all)[1:3] == c("sample.id", "fam", "sex"))) {
        stop("Unexpected first three column names")
      }
      
      ### Include samples with CNV but without phenotypes
      cnv.file <- paste0("CNVOutPop", npop, ".txt")
      
      cnvs <- read.table(file.path(pheno.path, cnv.file), sep = "", header = F)
      CNVs <- .checkConvertCNVs(cnvs, all.paths, dup.samples, n.cor)
      message(paste0("Number of CNVs", nrow(CNVs)))
      all.samples <- as.character(CNVs$V5)
      all.samples <- unique(all.samples)
      
      pheno.na <- cbind(as.data.frame(all.samples), fam = NA, sex = NA)
      colnames(pheno.na)[1] <- "sample.id"
      pheno.na$sample.id <- as.character(pheno.na$sample.id)
      pheno.na <- pheno.na[!(pheno.na$sample.id %in% all$sample.id), ]
      
      all <- plyr::rbind.fill(all, pheno.na)
      all[is.na(all)] <- -9
      
      ### Produce phen.info objects
      samplesPhen <- unique(all$sample.id)  ## Greb sample names
      phenotypes <- names(all[, 4:ncol(all), drop = FALSE])  ## Greb phenotype names
      
      phenotypesdf <- all[, 4:ncol(all), drop = FALSE]
      phenotypesdf <- as.data.frame(phenotypesdf)  ### Greb phenotypes values
      
      phenotypesSam <- data.frame(samplesPhen, phenotypesdf)
      phenotypesSam$samplesPhen <- as.character(phenotypesSam$samplesPhen)
      
      FamID <- data.frame(samplesPhen, V2 = all$fam[as.numeric(rownames(phenotypesSam))])
      SexIds <- data.frame(samplesPhen, V2 = all$sex[as.numeric(rownames(phenotypesSam))])
    }
    
    samplesPhen.all[[npop]] <- samplesPhen
    phenotypes.all[[npop]] <- phenotypes
    phenotypesdf.all[[npop]] <- phenotypesdf
    phenotypesSam.all[[npop]] <- phenotypesSam
    FamID.all[[npop]] <- FamID
    SexIds.all[[npop]] <- SexIds
  }
  
  samplesPhen <- unlist(samplesPhen.all)
  phenotypes <- unique(unlist(phenotypes.all))
  phenotypesdf <- data.table::rbindlist(phenotypesdf.all)
  phenotypesdf <- as.data.frame(phenotypesdf)
  phenotypesSam <- data.table::rbindlist(phenotypesSam.all)
  phenotypesSam <- as.data.frame(phenotypesSam)
  phenotypesSam[is.na(phenotypesSam)] <- -9
  FamID <- data.table::rbindlist(FamID.all)
  FamID <- as.data.frame(FamID)
  SexIds <- data.table::rbindlist(SexIds.all)
  SexIds <- as.data.frame(SexIds)
  
  if (!is.null(pops.names)) {
    
    all.pop.names <- NULL
    for (npop in seq_along(file.nam)) {
      all.pop.names[[npop]] <- rep(pops.names[npop], length(samplesPhen.all[[npop]]))
    }
    
    pops.names <- unlist(all.pop.names)
    phen.info <- list(samplesPhen = samplesPhen, phenotypes = phenotypes, phenotypesdf = phenotypesdf, 
                      phenotypesSam = phenotypesSam, FamID = FamID, SexIds = SexIds, pops.names = pops.names,
                      duplicated.samples = dup.samples)
  } else {
    phen.info <- list(samplesPhen = samplesPhen, phenotypes = phenotypes, phenotypesdf = phenotypesdf, 
                      phenotypesSam = phenotypesSam, FamID = FamID, SexIds = SexIds, duplicated.samples = dup.samples)
  }
  
  return(phen.info)
}

# HELPER - Check and convert CNV input @param cnvs Data-frame with the CNVs to be
# analyzed. From (i) PennCNV, (ii) SNP-chip general format or (iii) sequencing
# general format

.checkConvertCNVs <- function(cnvs, all.paths=NULL, dup.samples=NULL, n.cor = 1) {
  
  the.names <- as.character(as.matrix(cnvs[1, ]))
  stand.names <- c("chr", "start", "end", "sample.id", "state")
  stand.names.ext <- c(stand.names, "num.snps", "start.probe", "end.probe")
  ## If PennCNV file
  if (unique(sub("^([[:alpha:]]*).*", "\\1", cnvs$V2))[[1]] == "numsnp") {
    cnvs <- as.data.frame(cnvs)
    df1 <- reshape2::colsplit(cnvs$V1, ":", c("chr", "loc"))
    df2 <- reshape2::colsplit(df1$loc, "-", c("start", "end"))
    df1 <- cbind(df1[, -2, drop = FALSE], df2)
    
    cnvs <- cbind(df1, cnvs)
    cnvs$V1 <- gsub("chr", "", cnvs$V1)
    colnames(cnvs)[1:3] <- c("chr", "start", "end")
    CNVs <- cnvs
    
    ## If general format
  } else if (suppressWarnings(all(the.names == stand.names.ext))) {
    cnvs <- cnvs[-1, ]
    colnames(cnvs) <- the.names
    cnvs <- as.data.frame(cnvs)
    cnvs$start <- as.integer(cnvs$start)
    cnvs$end <- as.integer(cnvs$end)
    ## Convert to PennCNV format
    cnvs$V1 <- paste0(cnvs$chr, ":", cnvs$start, "-", cnvs$end)
    cnvs$length <- (cnvs$end - cnvs$start) + 1
    cnvs$length <- paste0("length=", cnvs$length)
    
    cnvs$num.snps <- paste0("numsnp=", cnvs$num.snps)
    
    cnvs$start.probe <- paste0("startSNP=", cnvs$start.probe)
    cnvs$end.probe <- paste0("endSNP=", cnvs$end.probe)
    
    cnvs <- cnvs[, c(stand.names[1:3], "V1", "num.snps", "length", "state", "sample.id", 
                     "start.probe", "end.probe")]
    colnames(cnvs)[5:10] <- c("V2", "V3", "V4", "V5", "V6", "V7")
    CNVs <- cnvs
    
    ## If sequencing info
  } else if (all(the.names == stand.names)) {
    cnvs <- as.data.frame(cnvs)
    
    ### Include artificial probe tags
    cnvs.seq <- cnvs
    cnvs.seq <- cnvs.seq[-1, ]
    colnames(cnvs.seq) <- the.names
    cnv.seq.gr <- GenomicRanges::makeGRangesFromDataFrame(cnvs.seq, keep.extra.columns = TRUE)
    chr.seq <- as.character(GenomicRanges::seqnames(cnv.seq.gr))
    start.seq <- GenomicRanges::start(cnv.seq.gr)
    start.seq <- data.frame(chr = chr.seq, position = start.seq, stringsAsFactors = FALSE)
    end.seq <- GenomicRanges::end(cnv.seq.gr)
    end.seq <- data.frame(chr = chr.seq, position = end.seq, stringsAsFactors = FALSE)
    dif <- GenomicRanges::end(cnv.seq.gr) - GenomicRanges::start(cnv.seq.gr)
    middle.seq <- GenomicRanges::end(cnv.seq.gr) - dif
    middle.seq <- data.frame(chr = chr.seq, position = middle.seq, stringsAsFactors = FALSE)
    arti.pr <- rbind(start.seq, end.seq, middle.seq)  # Bind all artifical probes
    arti.pr <- GenomicRanges::makeGRangesFromDataFrame(arti.pr, seqnames.field = "chr", 
                                                       start.field = "position", end.field = "position")
    arti.pr <- GenomicRanges::reduce(arti.pr)  ## Exclude duplicated positions
    arti.pr <- GenomeInfoDb::sortSeqlevels(arti.pr)
    arti.pr <- GenomicRanges::sort(arti.pr)
    
    probe.like.map <- as.data.frame(arti.pr)
    probe.like.map$Name <- paste0("probe.like_", seq_len(nrow(probe.like.map)))
    probe.like.map <- probe.like.map[, c("Name", "seqnames", "start")]
    colnames(probe.like.map) <- c("Name", "Chr", "Position")
    probe.like.map$Chr <- gsub("chr", "", probe.like.map$Chr)
    write.table(probe.like.map, file.path(all.paths[1], "MapPenn.txt"), row.names = FALSE, 
                quote = FALSE, sep = "\t")
    
    ## Associate artificial probes to CNVs
    
    probe.like.map.gr <- GenomicRanges::makeGRangesFromDataFrame(probe.like.map, 
                                                                 seqnames.field = "Chr", start.field = "Position", end.field = "Position", 
                                                                 keep.extra.columns = TRUE)
    
    ### HELPER - associate probes-like regions with CNVs
    .probeToCNVs <- function(lo, cnv.seq.gr, probe.like.map.gr) {
      cnvx <- cnv.seq.gr[lo]
      ov.pr <- IRanges::subsetByOverlaps(probe.like.map.gr, cnvx)
      num.snps <- length(ov.pr)
      start.probe <- ov.pr$Name[1]
      end.probe <- ov.pr$Name[length(ov.pr)]
      return(c(num.snps, start.probe, end.probe))
    }
    
    if (rappdirs:::get_os() == "win") {
      param <- BiocParallel::SnowParam(workers = n.cor, type = "SOCK")
      cnvs.probes <- suppressMessages(BiocParallel::bplapply(seq_along(cnv.seq.gr), 
                                                             .probeToCNVs, BPPARAM = param, cnv.seq.gr = cnv.seq.gr, probe.like.map.gr = probe.like.map.gr))
    }
    if (rappdirs:::get_os() == "unix" | rappdirs:::get_os() == "mac") {
      multicoreParam <- BiocParallel::MulticoreParam(workers = n.cor)
      cnvs.probes <- suppressMessages(BiocParallel::bplapply(seq_along(cnv.seq.gr), 
                                                             .probeToCNVs, BPPARAM = multicoreParam, cnv.seq.gr = cnv.seq.gr, 
                                                             probe.like.map.gr = probe.like.map.gr))
    }
    
    cnv.p.df <- t(as.data.frame(cnvs.probes))
    cnv.seq.gr$num.snps <- as.integer(as.character(cnv.p.df[, 1]))
    cnv.seq.gr$start.probe <- as.character(cnv.p.df[, 2])
    cnv.seq.gr$end.probe <- as.character(cnv.p.df[, 3])
    
    cnv.seq <- as.data.frame(cnv.seq.gr)
    cnv.seq <- cnv.seq[, c(1:3, 6:10)]
    colnames(cnv.seq)[1] <- "chr"
    
    cnvs <- cnv.seq
    cnvs$start <- as.integer(cnvs$start)
    cnvs$end <- as.integer(cnvs$end)
    
    ## Convert to PennCNV format
    cnvs$V1 <- paste0(cnvs$chr, ":", cnvs$start, "-", cnvs$end)
    cnvs$length <- (cnvs$end - cnvs$start) + 1
    cnvs$length <- paste0("length=", cnvs$length)
    
    cnvs$num.snps <- paste0("numsnp=", cnvs$num.snps)
    
    cnvs$start.probe <- paste0("startSNP=", cnvs$start.probe)
    cnvs$end.probe <- paste0("endSNP=", cnvs$end.probe)
    
    cnvs <- cnvs[, c(stand.names[1:3], "V1", "num.snps", "length", "state", "sample.id", 
                     "start.probe", "end.probe")]
    colnames(cnvs)[5:10] <- c("V2", "V3", "V4", "V5", "V6", "V7")
    CNVs <- cnvs
  } else stop("Unexpected CNV input format - is it tab delimited?")
  
  ### Check for duplicated samples and adjust the CNV file for it
  if(!is.null(dup.samples)){
    for(lo.dup in seq_along(dup.samples)){
      dup.samplesX <- dup.samples[lo.dup]
      dup.samplesX.split <- stringr::str_split(dup.samplesX, "\\.DupSampleExclu.")
      CNVs.sub <- subset(CNVs, V5%in%dup.samplesX.split[[1]][1]) 
      CNVs.sub$V5 <- dup.samplesX
      CNVs <- rbind(CNVs, CNVs.sub)
    }       
  }
  
  # Check for duplicated CNVs and exclude duplicated CNV entries
  CNVs.nodup <- CNVs[!duplicated(CNVs),]
  if(nrow(CNVs.nodup)!=nrow(CNVs)){
    warning("CNV dataset has duplicated entries. 
           A same CNV entry is present multiple times in at least one sample. 
           Only unique entries will be maintained.") 
  }
  CNVs <- CNVs.nodup  
  
  return(CNVs)
  
}

# HELPER - Load multiple CNV inputs @param cnv.file.all CNV file name @param
# cnv.path CNV path name

.loadToMergeCNV <- function(cnv.file.all, cnv.path) {
  ## Load and merge CNV files from multiple populations
  data.table::fread(file.path(cnv.path, cnv.file.all), header = TRUE)
}

# HELPER - Write CNV-genotype in a dosage-like fashion

.writeProbesCNV <- function(lo, all.samples, genofile, CNVsGr, probes.cnv.gr, n) {
  sampleX <- all.samples[lo]
  g <- SNPRelate::snpgdsGetGeno(genofile, sample.id = sampleX, verbose = FALSE)
  g <- drop(g)
  
  ind <- CNVsGr$V5 == sampleX
  CNVSamByState <- split(CNVsGr[ind], CNVsGr[ind]$V4)
  
  for (slo in seq_along(CNVSamByState)) {
    curr <- CNVSamByState[[slo]]
    curr4 <- curr$V4
    state <- unique(curr4)
    
    SamCNVSNP <- IRanges::subsetByOverlaps(probes.cnv.gr, curr)
    SamCNVSNP <- SamCNVSNP$snp.id
    g[SamCNVSNP] <- state
  }
  g <- as.integer(g)
  gdsfmt::write.gdsn(n, g, start = c(1, lo), count = c(length(g), 1))
}

# HELPER - Write CNV-genotype in a SNP-like fashion @param lo loop number @param
# genofile loaded gds file @param n is the object from \code{gdsfmt::add.gdsn}
# @param ranges.gr is the CNVs of each sample

.replaceSNPtoCNV <- function(lo, all.samples, genofile, CNVsGr, probes.cnv.gr, n) {
  sampleX <- all.samples[[lo]]
  g <- as.numeric(SNPRelate::snpgdsGetGeno(genofile, sample.id = sampleX, verbose = FALSE))
  
  # 2n
  g[seq_along(g)] <- "1"
  
  # 0n
  CNVsGr0n <- CNVsGr[CNVsGr$sample == sampleX]
  CNVsGr0n <- CNVsGr0n[CNVsGr0n$type == "state1,cn=0"]
  seqlevels(CNVsGr0n) <- seqlevels(probes.cnv.gr)
  probes.cnv.gr.0n <- IRanges::subsetByOverlaps(probes.cnv.gr, 
                                                CNVsGr0n)
  
  g[probes.cnv.gr.0n$tag.snp] <- "0"
  
  # 1n
  CNVsGr1n <- CNVsGr[CNVsGr$sample == sampleX]
  CNVsGr1n <- CNVsGr1n[CNVsGr1n$type == "state2,cn=1"]
  seqlevels(CNVsGr1n) <- seqlevels(probes.cnv.gr)
  probes.cnv.gr.1n <- IRanges::subsetByOverlaps(probes.cnv.gr, 
                                                CNVsGr1n)
  
  g[probes.cnv.gr.1n$tag.snp] <- "0"
  
  # 3n
  CNVsGr3n <- CNVsGr[CNVsGr$sample == sampleX]
  CNVsGr3n <- CNVsGr3n[CNVsGr3n$type == "state5,cn=3"]
  seqlevels(CNVsGr3n) <- seqlevels(probes.cnv.gr)
  probes.cnv.gr.3n <- IRanges::subsetByOverlaps(probes.cnv.gr, 
                                                CNVsGr3n)
  
  g[probes.cnv.gr.3n$tag.snp] <- "2"
  
  # 4n
  CNVsGr4n <- CNVsGr[CNVsGr$sample == sampleX]
  CNVsGr4n <- CNVsGr4n[CNVsGr4n$type == "state6,cn=4"]
  seqlevels(CNVsGr4n) <- seqlevels(probes.cnv.gr)
  probes.cnv.gr.4n <- IRanges::subsetByOverlaps(probes.cnv.gr, 
                                                CNVsGr4n)
  
  g[probes.cnv.gr.4n$tag.snp] <- "2"
  
  # 2n
  g <- as.integer(g)
  
  ### Replace the genotype in the gds file
  gdsfmt::write.gdsn(n, g, start = c(1, lo), count = c(length(g), 1))
  
}

# HELPER - Write CNV-genotype in SNP-like fashion in biallelic loci @param lo
# loop number, based on the number of SNPs per turn @param genofile loaded gds
# file @param n is the object from \code{gdsfmt::add.gdsn} @param chunk
# Intervals of SNP to import and convert @param coding.translate For
# 'CNVgenotypeSNPlike'. If NULL or unrecognized string use only biallelic CNVs.
# If 'all' code multiallelic CNVs as 0 for loss; 1 for 2n and 2 for gain.

.recodeCNVgenotype <- function(lo, genofile, all.samples, n, chunk, coding.translate) {
  
  count.end <- (chunk[lo + 1]) - chunk[lo]
  
  if (length(chunk) - 1 != lo) {
    CNVgenoX <- (g <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "CNVgenotype"), 
                                        start = c(chunk[lo], 1), count = c(count.end, length(all.samples))))
  } else {
    CNVgenoX <- (g <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "CNVgenotype"), 
                                        start = c(chunk[lo], 1), count = c(count.end + 1, length(all.samples))))
  }
  
  ### Put four copies as max
  CNVgenoX[CNVgenoX > 4] <- 4
  CNVgenoX <- as.data.frame(CNVgenoX)
  
  CNVgenoX$zn <- 0
  CNVgenoX$on <- 1
  CNVgenoX$tn <- 2
  CNVgenoX$thn <- 3
  CNVgenoX$fn <- 4
  
  ### Count genotypes
  genos <- apply(CNVgenoX, 1, table)
  genos <- genos - 1
  genos <- t(genos)
  
  #### Recode genotypes
  sum12 <- apply(genos[, 1:2], 1, sum)   
  sum45 <- apply(genos[, 4:5], 1, sum)
  indexLoss <- (sum12 > 0) & (sum45 == 0)
  indexGain <- (sum12 == 0) & (sum45 > 0)
  indexExclude <- (sum12 > 0) & (sum45 > 0)
  
  ## Exclude index in the matrix
  CNVgenoX <- CNVgenoX[, -((ncol(CNVgenoX) - 4):ncol(CNVgenoX))]
  
  ### To character
  CNVgenoX <- t(apply(CNVgenoX, 1, paste0, "n"))
  
  ### Replace Gain
  CNVgenoX[indexGain, ] <- gsub("2n", "0", CNVgenoX[indexGain, ])
  CNVgenoX[indexGain, ] <- gsub("3n", "1", CNVgenoX[indexGain, ])
  CNVgenoX[indexGain, ] <- gsub("4n", "2", CNVgenoX[indexGain, ])
  
  ### Replace Loss
  CNVgenoX[indexLoss, ] <- gsub("2n", "0", CNVgenoX[indexLoss, ])
  CNVgenoX[indexLoss, ] <- gsub("1n", "1", CNVgenoX[indexLoss, ])
  CNVgenoX[indexLoss, ] <- gsub("0n", "2", CNVgenoX[indexLoss, ])
  
  
  ## Non bi-allelic CNVs = no genotype
  if (is.null(coding.translate)) {
    coding.translate <- "biallelic"
  }
  if (coding.translate == "all") {
    CNVgenoX[indexExclude, ] <- gsub("4n", "2", CNVgenoX[indexExclude, ])
    CNVgenoX[indexExclude, ] <- gsub("3n", "2", CNVgenoX[indexExclude, ])
    CNVgenoX[indexExclude, ] <- gsub("2n", "1", CNVgenoX[indexExclude, ])
    CNVgenoX[indexExclude, ] <- gsub("1n", "0", CNVgenoX[indexExclude, ])
    CNVgenoX[indexExclude, ] <- gsub("0n", "0", CNVgenoX[indexExclude, ])
  } else {
    CNVgenoX[indexExclude, ] <- -1
  }
  
  CNVgenoX <- apply(CNVgenoX, 2, as.integer)
  
  ### Replace the genotype in the gds file
  if (length(chunk) - 1 != lo) {
    gdsfmt::write.gdsn(n, CNVgenoX, start = c(chunk[lo], 1), count = c(count.end, 
                                                                       length(all.samples)))
  } else {
    gdsfmt::write.gdsn(n, CNVgenoX, start = c(chunk[lo], 1), count = c(count.end + 
                                                                         1, length(all.samples)))
  }
}

# HELPER Wait x seconds # from
# https://stat.ethz.ch/R-manual/R-devel/library/base/html/Sys.sleep.html

testit <- function(x) {
  p1 <- proc.time()
  Sys.sleep(x)
  proc.time() - p1
}

# HELPER - Produce the probes.cnv.gr

.prodProbes <- function(phen.info, lo.phe = 1, freq.cn = 0.01) {
  
  phenotypesSam <- phen.info$phenotypesSam
  samplesPhen <- phen.info$samplesPhen
  FamID <- phen.info$FamID
  SexIds <- phen.info$SexIds
  all.paths <- phen.info$all.paths
  dup.samples <- phen.info$duplicated.samples
  
  phenotypesSamX <- phenotypesSam[, c(1, (lo.phe + 1))]
  
  ###################### Import CNVs to data-frame
  
  cnvs <- data.table::fread(file.path(all.paths[1], "CNVOut.txt"), sep = "\t", 
                            header = FALSE)  ### CNV table 
  
  CNVs <- .checkConvertCNVs(cnvs, all.paths, dup.samples)
  message(paste0("Number of CNVs", nrow(CNVs)))
  
  ####################### Check if the chromosomes are numeric
  
  chr.names <- CNVs$chr
  chr.names <- gsub("chr", "", chr.names)
  
  if (any(is.na(chr.names))) {
    stop("Chromosome names should be integers. If they are not, make them integers and include the correspondent names 
         in chr.code.name parameter")
  }
  
  ############################# 
  
  CNVs$start <- as.integer(as.character(CNVs$start))
  CNVs$end <- as.integer(as.character(CNVs$end))
  CNVsGr <- GenomicRanges::makeGRangesFromDataFrame(CNVs, keep.extra.columns = TRUE)
  CNVsGr <- CNVsGr[CNVsGr$V5 %in% samplesPhen]  ### Subset CNVs in phenotyped samples
  
  ###################### Import SNP map to data-frame
  probes <- data.table::fread(file.path(all.paths[1], "MapPenn.txt"), header = TRUE, 
                              sep = "\t")
  probes <- as.data.frame(probes)
  probes$Position <- as.integer(as.character(probes$Position))
  probes <- probes[stats::complete.cases(probes), ]
  probesGr <- GenomicRanges::makeGRangesFromDataFrame(probes, seqnames.field = "Chr", 
                                                      start.field = "Position", end.field = "Position", keep.extra.columns = TRUE)
  
  all.samples <- unique(as.character(CNVsGr$V5))
  
  ###################### Select probes within CNVs
  seqlevels(CNVsGr) <- seqlevels(probesGr)
  probesCNV <- as.character(IRanges::subsetByOverlaps(probesGr, 
                                                      CNVsGr)$Name)
  probesCNV <- unique(unlist(probesCNV))
  probes.cnv.gr <- probesGr[probesGr$Name %in% probesCNV]
  
  counts <- GenomicRanges::countOverlaps(probes.cnv.gr, CNVsGr)
  probes.cnv.gr$freq <- unname(counts)
  
  ##### Subset by frequency
  NumSam <- freq.cn * length(all.samples)
  probes.cnv.gr <- probes.cnv.gr[probes.cnv.gr$freq >= NumSam]
  
  ##### Order the probes
  probes.cnv.gr <- GenomeInfoDb::sortSeqlevels(probes.cnv.gr)
  probes.cnv.gr <- GenomicRanges::sort(probes.cnv.gr)
  
  probes.cnv.gr$snp.id <- seq_along(probes.cnv.gr)
  
  return(probes.cnv.gr)
  }


# HELPER - Internal function of parallel implementation to produce the .gvar file
# (absolute copy number) requested for the CNV-GWAS in PLINK @examples Gens <-
# .prodGvar(lo, genofile, sam.gen, snps, fam.id)

.prodGvar <- function(lo, genofile, sam.gen, snps, fam.id, snp.matrix) {
  g <- as.numeric(SNPRelate::snpgdsGetGeno(genofile, sample.id = sam.gen[[lo]], 
                                           verbose = FALSE))
  A <- rep("A", length(gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "CNVgenotype"), 
                                         start = c(1, lo), count = c(length(g), 1))))
  B <- rep("B", length(gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "CNVgenotype"), 
                                         start = c(1, lo), count = c(length(g), 1))))
  CNVg <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "CNVgenotype"), start = c(1, 
                                                                                   lo), count = c(length(g), 1))
  CNVg <- CNVg - 1
  Dose1 <- rep(1, length(CNVg))
  Dose1[CNVg == -1] <- 0
  CNVg[CNVg == -1] <- 0
  B[CNVg == 1] <- "A"
  
  if (!snp.matrix) {
    df <- as.data.frame(cbind(as.character(fam.id[[lo]]), sam.gen[[lo]], snps, 
                              A, CNVg, B, Dose1))
    colnames(df) <- c("FID", "IID", "NAME", "ALLELE1", "DOSAGE1", "ALLELE2", 
                      "DOSAGE2")
  } else stop("Option to consider SNP matrix is not implemented yet") 
  
  return(df)
}


# HELPER - Internal function of parallel implementation to produce the .gvar file
# (LRR) requested for the CNV-GWAS in PLINK @examples Gens <- .prodGvarLRR(lo,
# genofile, sam.gen, snps, fam.id)

.prodGvarLRR <- function(lo, genofile, sam.gen, snps, fam.id, snp.matrix) {
  
  ## Transform LRR calclulations into genotypes
  g <- as.numeric(SNPRelate::snpgdsGetGeno(genofile, sample.id = sam.gen[[lo]], 
                                           verbose = FALSE))
  A <- rep("A", length(gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "CNVgenotype"), 
                                         start = c(1, lo), count = c(length(g), 1))))
  B <- rep("B", length(gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "CNVgenotype"), 
                                         start = c(1, lo), count = c(length(g), 1))))
  LRRg <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "LRR"), start = c(1, lo), 
                            count = c(length(g), 1))
  LRRg[is.na(LRRg)] <- 0
  
  CNVg <- LRRg
  Dose1 <- rep(0, length(CNVg))
  
  
  if (!snp.matrix) {
    df <- as.data.frame(cbind(as.character(fam.id[[lo]]), sam.gen[[lo]], snps, 
                              A, CNVg, B, Dose1))
    colnames(df) <- c("FID", "IID", "NAME", "ALLELE1", "DOSAGE1", "ALLELE2", 
                      "DOSAGE2")
  } else {
    stop("Option to consider SNP matrix is not implemented yet")  
    ## CHECK IF WE HAVE THE SAME SAMPLES
    ## INCLUDE NA FOR SAMPLES WITH ONLY ONE GENOTYPE TYPE? (i.e CNV or SNP)
  }
  return(df)
}

# HELPER - Produce PLINK probe map in disk

.prodPLINKmap <- function(all.paths) 
{
  cnv.gds <- file.path(all.paths[1], "CNV.gds")
  genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE)
  Pmap <- as.data.frame(cbind(
    gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "snp.chromosome")), 
    gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "snp.rs.id")), 
    0, gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "snp.position"))))
  
  colnames(Pmap) <- c("Chr", "NAME", "GD", "Position")
  map.file <- file.path(all.paths[2], "mydata.map")
  write.table(Pmap, map.file, sep = "\t", row.names = FALSE, quote = FALSE)
  SNPRelate::snpgdsClose(genofile)
}

# HELPER - Produce the PLINK .gvar file in disk

.prodPLINKgvar <- function(all.paths, n.cor, snp.matrix, run.lrr = FALSE) 
{
  cnv.gds <- file.path(all.paths[1], "CNV.gds")
  genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE, readonly = FALSE)
  sam.gen <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "sample.id"))
  snps <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "snp.rs.id"))
  fam.id <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "FamID"))
  
  ## Produce gvar file in parallel processing Identify the SO
  if (run.lrr) {
    if (rappdirs:::get_os() == "unix" | rappdirs:::get_os() == "mac") {
      multicoreParam <- BiocParallel::MulticoreParam(workers = n.cor)
      Gens <- suppressMessages(BiocParallel::bplapply(1:length(sam.gen), .prodGvarLRR, 
                                                      BPPARAM = multicoreParam, genofile = genofile, sam.gen = sam.gen, 
                                                      snps = snps, fam.id = fam.id, snp.matrix = snp.matrix))
    }
    
    if (rappdirs:::get_os() == "win") {
      param <- BiocParallel::SnowParam(workers = n.cor, type = "SOCK")
      Gens <- suppressMessages(BiocParallel::bplapply(1:length(sam.gen), .prodGvarLRR, 
                                                      BPPARAM = param, genofile = genofile, sam.gen = sam.gen, snps = snps, 
                                                      fam.id = fam.id, snp.matrix = snp.matrix))
    }
    
  } else {
    if (rappdirs:::get_os() == "unix" | rappdirs:::get_os() == "mac") {
      multicoreParam <- BiocParallel::MulticoreParam(workers = n.cor)
      Gens <- suppressMessages(BiocParallel::bplapply(1:length(sam.gen), .prodGvar, 
                                                      BPPARAM = multicoreParam, genofile = genofile, sam.gen = sam.gen, 
                                                      snps = snps, fam.id = fam.id, snp.matrix = snp.matrix))
    }
    
    if (rappdirs:::get_os() == "win") {
      param <- BiocParallel::SnowParam(workers = n.cor, type = "SOCK")
      Gens <- suppressMessages(BiocParallel::bplapply(1:length(sam.gen), .prodGvar, 
                                                      BPPARAM = param, genofile = genofile, sam.gen = sam.gen, snps = snps, 
                                                      fam.id = fam.id, snp.matrix = snp.matrix))
    }
    
  }
  
  gentype.all <- data.table::rbindlist(Gens)
  gentype.all1 <- as.data.frame(gentype.all)
  
  gvar.file <- file.path(all.paths[2], "mydata.gvar")
  write.table(gentype.all1, gvar.file, sep = "\t", row.names = FALSE, quote = FALSE)
  SNPRelate::snpgdsClose(genofile)
}


# HELPER - Produce the PLINK fam file in disk

.prodPLINKfam <- function(all.paths) 
{
  cnv.gds <- file.path(all.paths[1], "CNV.gds")
  genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE, readonly = FALSE)
  SamGen <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "sample.id"))
  SNPs <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "snp.rs.id"))
  FAMID <- as.character(gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "FamID")))
  Sex <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "Sex"))
  Phen <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "phenotype"))
  
  famdf <- data.frame(FAMID, SamGen, SamGen, "NC", Sex, as.numeric(Phen[, 2]))
  colnames(famdf) <- c("FAID", "IID", "PID", "MID", "Sex", "Phenotype")
  
  fam.file <- file.path(all.paths[2], "mydata.fam")
  write.table(famdf, fam.file, sep = "\t", row.names = FALSE, quote = FALSE)
  SNPRelate::snpgdsClose(genofile)
}

# HELPER - Run PLINK

.runPLINK <- function(all.paths) {
  
  if (rappdirs:::get_os() == "win" | rappdirs:::get_os() == "unix") {
    plinkPath <- file.path(all.paths[2], "plink")
    #plinkPath <- all.paths[2]
    plinkPath <- gsub("\\\\", "/", plinkPath)
    system(paste(plinkPath, "--gfile", file.path(all.paths[2], "mydata"), paste("--out", 
                                                                                file.path(all.paths[2], "plink")), "--noweb"), wait = TRUE, intern = TRUE)
  }
  
  if (rappdirs:::get_os() == "mac") {
    plink.path <- file.path(all.paths[2], "plink")
    mydata <- file.path(all.paths[2], "mydata")
    mydata <- paste0("'", mydata, "'")
    plink <- file.path(all.paths[2], "plink")
    plink <- paste0("'", plink, "'")
    args <- c("--gfile", mydata, "--out", plink, "--noweb", "--allow-no-sex")
    system2(plink.path, args = args)
  }
  
  cnv.gds <- file.path(all.paths[1], "CNV.gds")
  genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE, readonly = FALSE)
  sumphen <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "phenotype"))
  sumphen <- paste0("plink.gvar.summary.", names(sumphen)[[2]])
  
  from <- file.path(all.paths[2], "plink.gvar.summary")
  to <- file.path(all.paths[2], sumphen)
  file.rename(from, to)
  SNPRelate::snpgdsClose(genofile)
}

# HELPER - Produce CNV segments

.prodCNVseg <- function(all.paths, probes.cnv.gr, min.sim, both.up.down) 
{
  cnv.gds <- file.path(all.paths[1], "CNV.gds")
  genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE, readonly = FALSE)
  
  snp.chr <-  gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "snp.chromosome")) 
  chrx <- data.frame(V1=snp.chr, V2=seq_along(snp.chr))
  g1 <- g2 <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "CNVgenotype"))
  
  chrx$V1 <- factor(chrx$V1, levels = unique(chrx$V1))
  chrx.split <- split(chrx, chrx$V1)
  
  # Find similarity between subsequent probes upstream 
  # g1 <- apply(g1,2,rev) 
  # g2 <- apply(g2,2,rev)
  SimiLar.all <- NULL
  for (lo in seq_along(chrx.split)) {
    snpindex <- as.numeric(as.character(chrx.split[[lo]]$V2))
    
    if (length(snpindex) == 1) {
      SimiLar.all[[lo]] <- "UNIQUE"
      next
    }
    
    g1x <- g1[snpindex, ]
    g1x <- apply(g1x, 2, rev)
    
    if (length(snpindex) == 2) {
      g1x <- rbind(g1x, rep(2, ncol(g1x)))  # If only two SNPs input a 2n row
    }
    
    g1xM <- g1x[-(nrow(g1x)), ]
    
    
    g1CN <- apply(g1xM, 1, function(x) sum(table(x)[names(table(x)) != 2]))
    g1x <- as.data.frame(t(sapply(1:nrow(g1x), function(i) replace(g1x[i, ], 
                                                                   g1x[i, ] == 2, paste0(i, "R")))))
    
    g2x <- g2[snpindex, ]
    g2x <- apply(g2x, 2, rev)
    
    if (length(snpindex) == 2) {
      g2x <- rbind(g2x, rep(2, ncol(g2x)))  # If only two SNPs input a 2n row
    }
    
    g2x <- as.data.frame(t(sapply(1:nrow(g2x), function(i) replace(g2x[i, ], 
                                                                   g2x[i, ] == 2, paste0(i, "R")))))
    g1x <- g1x[-(nrow(g1x)), ]
    g2x <- g2x[-1, ]
    ftma <- g1x == g2x
    SimiLar <- apply(ftma, 1, function(x) as.numeric(table(x)["TRUE"]))
    SimiLar[is.na(SimiLar)] <- 0
    
    simX <- as.numeric(SimiLar)/g1CN
    if (length(snpindex) == 2) {
      simX <- simX[-2]
    }
    
    SimiLar.all[[lo]] <- simX  ### CNV genotype similarity between subsequent SNPs
  }
  SimiLar.all.Up <- SimiLar.all
  
  ### Find similarity between subsequent probes Downstream
  SimiLar.all <- NULL
  for (lo in seq_along(chrx.split)) {
    snpindex <- as.numeric(as.character(chrx.split[[lo]]$V2))
    
    if (length(snpindex) == 1) {
      SimiLar.all[[lo]] <- "UNIQUE"
      next
    }
    
    g1x <- g1[snpindex, ]
    
    if (length(snpindex) == 2) {
      g1x <- rbind(g1x, rep(2, ncol(g1x)))  # If only two SNPs input a 2n row
    }
    
    g1xM <- g1x[-(nrow(g1x)), ]
    
    
    g1CN <- apply(g1xM, 1, function(x) sum(table(x)[names(table(x)) != 2]))
    g1x <- as.data.frame(t(sapply(1:nrow(g1x), function(i) replace(g1x[i, ], 
                                                                   g1x[i, ] == 2, paste0(i, "R")))))
    
    g2x <- g2[snpindex, ]
    
    if (length(snpindex) == 2) {
      g2x <- rbind(g2x, rep(2, ncol(g2x)))  # If only two SNPs input a 2n row
    }
    
    g2x <- as.data.frame(t(sapply(1:nrow(g2x), function(i) replace(g2x[i, ], 
                                                                   g2x[i, ] == 2, paste0(i, "R")))))
    g1x <- g1x[-(nrow(g1x)), ]
    g2x <- g2x[-1, ]
    ftma <- g1x == g2x
    SimiLar <- apply(ftma, 1, function(x) as.numeric(table(x)["TRUE"]))
    SimiLar[is.na(SimiLar)] <- 0
    
    simX <- as.numeric(SimiLar)/g1CN
    if (length(snpindex) == 2) {
      simX <- simX[-2]
    }
    
    SimiLar.all[[lo]] <- simX  ### CNV genotype similarity between subsequent SNPs
  }
  SimiLar.all.Down <- SimiLar.all
  
  if (both.up.down) {
    for (lo in seq_along(SimiLar.all)) {
      SimiLar.all[[lo]] <- pmin(SimiLar.all.Up[[lo]], SimiLar.all.Down[[lo]])
    }
  }
  
  ### Produce segments
  all.segs <- NULL
  for (ch in seq_along(SimiLar.all)) {
    SimiLarX <- SimiLar.all[[ch]]
    if (all(SimiLarX == "UNIQUE")) {
      all.segs[[ch]] <- "start"
      next
    }
    nextP <- NULL
    all.segsch <- NULL
    for (se in seq_along(SimiLarX)) {
      if (SimiLarX[[se]] >= min.sim) {
        nextP[[se]] <- "TRUE"
      }
      if (SimiLarX[[se]] < min.sim) {
        nextP[[se]] <- "FALSE"
      }
      
      if (se == 1) {
        all.segsch[[se]] <- "start"
      }
      
      if (se > 1) {
        if (nextP[[se - 1]] == "TRUE") {
          all.segsch[[se]] <- "cont"
        }
        if (nextP[[se - 1]] == "FALSE") {
          all.segsch[[se]] <- "start"
        }
      }
      
      if (se == length(SimiLarX)) {
        if (SimiLarX[[se]] >= min.sim) {
          all.segsch[[se + 1]] <- "cont"
        }
        if (SimiLarX[[se]] < min.sim) {
          all.segsch[[se + 1]] <- "start"
        }
      }
      
    }
    all.segs[[ch]] <- all.segsch
  }
  
  probes.cnv.gr$starts.seg <- unlist(all.segs)
  
  pstarts <- probes.cnv.gr[probes.cnv.gr$starts.seg == "start"]
  pstarts.split = split(pstarts, GenomeInfoDb::seqnames(pstarts))
  
  options(warn = -1)
  all.segs.gr <- GenomicRanges::GRangesList()
  for (chx in seq_along(pstarts.split)) {
    pstartsx <- pstarts.split[[chx]]
    if (!length(pstartsx)) {
      all.segs.gr[[chx]] <- GenomicRanges::reduce(pstartsx)  #Empty if no segments
      next
    }
    all.segs.grX <- GenomicRanges::GRangesList()
    for (st in seq_along(pstartsx)) {
      prx <- pstartsx[st]
      if (st < length(pstartsx)) {
        LimPrx <- GenomicRanges::start(pstartsx[st + 1]) - 1
      }
      if (st == length(pstartsx)) {
        sel.probes <- probes.cnv.gr[GenomeInfoDb::seqnames(probes.cnv.gr) == 
                                      GenomeInfoDb::seqnames(prx)]
        LimPrx <- max(GenomicRanges::start(sel.probes))
      }
      seqLar <- GenomicRanges::GRanges(as.character(GenomeInfoDb::seqnames(prx)), 
                                       IRanges::IRanges(GenomicRanges::start(prx), LimPrx))
      seqlevels(seqLar) <- seqlevels(probes.cnv.gr)
      seqPrbs <- IRanges::subsetByOverlaps(probes.cnv.gr, 
                                           seqLar)
      seqx <- GenomicRanges::GRanges(as.character(GenomeInfoDb::seqnames(prx)), 
                                     IRanges::IRanges(GenomicRanges::start(prx), GenomicRanges::start(seqPrbs[length(seqPrbs)])))
      all.segs.grX[[st]] <- seqx
    }
    all.segs.gr[[chx]] <- suppressWarnings(unlist(all.segs.grX))
  }
  options(warn = 0)
  
  SNPRelate::snpgdsClose(genofile)
  
  return(all.segs.gr)
  
}


# HELPER - Associate probes with CNV segments and draw p-values

.assoPrCNV <- function(all.paths, all.segs.gr, phenotypesSamX, method.m.test, 
                       probes.cnv.gr, assign.probe = "min.pvalue", correct.inflation,
                       association.method="plink", all.pvalues=NULL, simulation=NULL, 
                       genofile=NULL) {
  
  segs.pvalue.gr <- unlist(all.segs.gr)
  segs.pvalue.gr$SegName <- seq_along(segs.pvalue.gr)
  
  if(is.null(simulation)){
  cnv.gds <- file.path(all.paths[1], "CNV.gds")
  genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE, readonly = FALSE)}
  
  if(association.method=="plink"){
  gvar.name <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "phenotype"))
  gvar.name <- names(gvar.name)[[2]]
  sum.file <- paste0("plink.gvar.summary.", gvar.name)
  results <- read.table(file.path(all.paths[2], sum.file), header = TRUE)
  mydata.map <- read.table(file.path(all.paths[2], "mydata.map"), header = TRUE)
  resultsp <- merge(results, mydata.map, by.x = "NAME", by.y = "NAME", all.x = TRUE, 
                    all.y = FALSE)
  
  # Choose the method
  # TODO: change if SNPMatrix implemented
  # allow to get other p-values
  resultsp <- resultsp[grep("P\\(CNP\\)", resultsp$FIELD), ]
  resultsp$VALUE <- as.numeric(as.character(resultsp$VALUE))
  resultsp$VALUE <- round(resultsp$VALUE, digits = 5)
  
  #### Correct for genomic inflation
  all.samples <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "sample.id"))
  if (correct.inflation) {
    #### Calculating chi-square distribution based on original P-values
    chisq.n <- qchisq(resultsp$VALUE, 1, lower.tail = FALSE)
    ### Estimating genomic inflation factor
    lambda <- estlambda(resultsp$VALUE, filter = FALSE)$estimate
    if(TRUE){ ## TODO: Continue with Sandrine strategy?
    ### correcting the qui-square distribution with lambda
    chisq_corr = chisq.n/lambda
    #### re-calculating corrected P values
    resultsp$VALUE = pchisq(chisq_corr, 1, lower.tail = FALSE)}
    if(FALSE){ 
      resultsp$VALUE = resultsp$VALUE/lambda
    }
  }
  
  resultsp <- resultsp[order(resultsp$VALUE), ]
  resultspGr <- GenomicRanges::makeGRangesFromDataFrame(resultsp, seqnames.field = "Chr", 
                                                        start.field = "Position", end.field = "Position", 
                                                        keep.extra.columns = TRUE)
  
  }else if(association.method=="p.values"){
    lmm.results <- probes.cnv.gr
    values(lmm.results)$VALUE <- all.pvalues 
    colnames(mcols(lmm.results))[1] <- "NAME"

    if (correct.inflation) {
      #### Calculating chi-square distribution based on original P-values
      chisq.n <- qchisq(values(lmm.results)$VALUE, 1, lower.tail = FALSE)
      ### Estimating genomic inflation factor
      lambda <- estlambda(values(lmm.results)$VALUE, filter = FALSE)$estimate
      ### correcting the qui-square distribution with lambda
      chisq_corr = chisq.n/lambda
      #### re-calculating corrected P values
      values(lmm.results)$VALUE = pchisq(chisq_corr, 1, lower.tail = FALSE)
    }
    resultspGr <- lmm.results

  }else{
    stop("Only plink or lmm.pedigree permitted")
  }
  
  ######## Assign the lowest p-value to the CNV segment
  
  values.all <- vector("list", length(segs.pvalue.gr))
  names.all <- vector("list", length(segs.pvalue.gr))
  freqs.all <- vector("list", length(segs.pvalue.gr))
  
  if (assign.probe == "min.pvalue") {
    for (se in seq_along(segs.pvalue.gr)) {
      Prbx <- IRanges::subsetByOverlaps(resultspGr, segs.pvalue.gr[se])
      if (length(Prbx)) {
        values.all[[se]] <- min(Prbx$VALUE)
        names.all[[se]] <- as.character(Prbx[Prbx$VALUE %in% values.all[[se]]]$NAME[[1]])
        probe.sel <- Prbx[order(Prbx$VALUE)][1]
        probe.sel <- IRanges::subsetByOverlaps(probes.cnv.gr, probe.sel)
        freqs.all[[se]] <- as.character(probe.sel$freq[1])
      } else {
        probe.sel <- IRanges::subsetByOverlaps(probes.cnv.gr, segs.pvalue.gr[se])[1]
        values.all[[se]] <- 1
        names.all[[se]] <- as.character(probe.sel$Name)
        freqs.all[[se]] <- as.character(probe.sel$freq[1])
      }
    }
  }
  
  if (assign.probe == "high.freq") {
    for (se in seq_along(segs.pvalue.gr)) {
      seqlevels(segs.pvalue.gr) <- seqlevels(probes.cnv.gr)
      probe.sel <- IRanges::subsetByOverlaps(probes.cnv.gr, 
                                             segs.pvalue.gr[se])
      probe.sel <- probe.sel[rev(order(probe.sel$freq))][1]
      ## Take the first probe if the position is duplicated
      seqlevels(probe.sel) <- seqlevels(resultspGr)
      resultX <- IRanges::subsetByOverlaps(resultspGr, probe.sel)[1]
      values.all[[se]] <- resultX$VALUE
      names.all[[se]] <- as.character(probe.sel$Name)
      freqs.all[[se]] <- as.character(probe.sel$freq[1])
    }
  }
  
  if (assign.probe == "median") {
    for (se in seq_along(segs.pvalue.gr)) {
      seqlevels(segs.pvalue.gr) <- seqlevels(probes.cnv.gr)
      probe.sel <- IRanges::subsetByOverlaps(probes.cnv.gr, 
                                             segs.pvalue.gr[se])
      absdiff <- abs(probe.sel$freq - median(probe.sel$freq))
      probe.sel <- probe.sel[which.min(absdiff)]
      ## Take the first probe if the position is duplicated
      seqlevels(probe.sel) <- seqlevels(resultspGr)
      resultX <- IRanges::subsetByOverlaps(resultspGr, probe.sel)[1]
      values.all[[se]] <- resultX$VALUE
      names.all[[se]] <- as.character(probe.sel$Name)
      freqs.all[[se]] <- as.character(probe.sel$freq[1])
    }
  }
  
  if (assign.probe == "mean") {
    for (se in seq_along(segs.pvalue.gr)) {
      seqlevels(segs.pvalue.gr) <- seqlevels(probes.cnv.gr)  
      probe.sel <- IRanges::subsetByOverlaps(probes.cnv.gr, 
                                             segs.pvalue.gr[se])
      absdiff <- abs(probe.sel$freq - mean(probe.sel$freq))
      probe.sel <- probe.sel[which.min(absdiff)]
      ## Take the first probe if the position is duplicated
      seqlevels(probe.sel) <- seqlevels(resultspGr)  
      resultX <- IRanges::subsetByOverlaps(resultspGr, probe.sel)[1]
      values.all[[se]] <- resultX$VALUE
      names.all[[se]] <- as.character(probe.sel$Name)
      freqs.all[[se]] <- as.character(probe.sel$freq[1])
    }
  }
  
  if (assign.probe == "combine.pvalue") {
    for (se in seq_along(segs.pvalue.gr)) {
      seqlevels(segs.pvalue.gr) <- seqlevels(probes.cnv.gr)
      probe.sel <- IRanges::subsetByOverlaps(probes.cnv.gr, 
                                             segs.pvalue.gr[se])
      #absdiff <- abs(probe.sel$freq - median(probe.sel$freq))
      #probe.sel <- probe.sel[which.min(absdiff)]
      ## Take the first probe if the position is duplicated
      seqlevels(probe.sel) <- seqlevels(resultspGr)
      resultX <- IRanges::subsetByOverlaps(resultspGr, probe.sel)
      #combined.pvalue <- survcomp::combine.test(resultX$VALUE, na.rm = TRUE, method ="z.transform")
      combined.pvalue <- median(resultX$VALUE)
      absdiff <- abs(resultX$VALUE - median(resultX$VALUE))
      resultX <- resultX[which.min(absdiff)][1]
      probe.sel <- IRanges::subsetByOverlaps(probe.sel, resultX)
      values.all[[se]] <- combined.pvalue
      probe.sel <- probe.sel[1] ## Improve to select probe with the p-value closest to the combined
      names.all[[se]] <- as.character(probe.sel$Name)
      freqs.all[[se]] <- as.character(probe.sel$freq[1])
    }
  }
  
  segs.pvalue.gr$MinPvalue <- unlist(values.all)
  segs.pvalue.gr$NameProbe <- unlist(names.all)
  segs.pvalue.gr$Frequency <- unlist(freqs.all)
  
  segs.pvalue.gr$MinPvalueAdjusted <- stats::p.adjust(segs.pvalue.gr$MinPvalue, 
                                                      method = method.m.test, n = length(segs.pvalue.gr))
  segs.pvalue.gr$Phenotype <- names(phenotypesSamX)[[2]]
  segs.pvalue.gr$MinPvalueAdjusted <- round(segs.pvalue.gr$MinPvalueAdjusted, 5)
  
  ## Write the probe-pvalues
  if(is.null(simulation)){
  gdsfmt::add.gdsn(genofile, name = "probe.pvalues", val= values(resultspGr)$VALUE, replace = TRUE)
  SNPRelate::snpgdsClose(genofile)}
  
  return(segs.pvalue.gr)
  
}

# HELPER - Function to apply during LRR/BAF import @param lo loop number, based
# on the number of SNPs per turn @param list.filesLo Data-frame with two columns
# where the (i) is the path + file name with signals and (ii) is the
# correspondent name of the sample in the gds file @param genofile loaded gds
# file @param all.samples All samples in the gds file @param nLRR Connection to
# write LRR values @param nBAF Connection to write BAF values @param
# snps.included All SNP probe names to be included @param verbose Print the
# samples while importing

.freadImport <- function(lo, list.filesLo, genofile, all.samples, nLRR = NULL, nBAF = NULL, 
                         snps.included, verbose) {
  
  if (verbose) message(paste0("sample ", lo, " of ", length(all.samples)))
  
  file.x <- c(as.character(list.filesLo[lo, 1]), as.character(list.filesLo[lo,2]))
  
  ### Import the sample file with fread
  sig.x <- data.table::fread(file.x[1], skip = 1L, header = FALSE)
  sig.x <- as.data.frame(sig.x)
  colnames(sig.x) <- c("name", "chr", "position", "lrr", "baf")
  
  ### Order the signal file as in the gds
  ind <- as.vector(sig.x$name) %in% snps.included
  sig.x <- sig.x[ind, ]
  
  ### Include missing SNPs
  missing.snps <- snps.included[!(snps.included %in% sig.x$name)]
  if (length(missing.snps) > 0) {
    missing.snps <- as.data.frame(missing.snps)
    missing.snps <- cbind(missing.snps, chr = "NoN", position = "NoN", lrr = NA, 
                          baf = NA)
    colnames(missing.snps)[1] <- "name"
    sig.x <- rbind(sig.x, missing.snps)
  }
  
  sig.x <- sig.x[order(match(sig.x[, 1], snps.included)), ]
  
  ### Extract the LRR
  LRR.x <- sig.x$lrr
  
  ### Extract the BAF
  BAF.x <- sig.x$baf
  
  ### Find the number of the sample
  sam.num <- which(all.samples == file.x[2])
  
  if (!is.null(nLRR)) {
    ### Write LRR value for sample x
    gdsfmt::write.gdsn(nLRR, LRR.x, start = c(1, sam.num), count = c(length(snps.included), 
                                                                     1))
  } else if (!is.null(nBAF)) {
    ### Write BAF value for sample x
    gdsfmt::write.gdsn(nBAF, BAF.x, start = c(1, sam.num), count = c(length(snps.included), 
                                                                     1))
  }
  
}

# HELPER - Estimate lambda - From GeneAbel package that was temporarily removed from CRAN
estlambda <- function(data, plot = FALSE, proportion = 1, method = "regression", 
                      filter = TRUE, df = 1, ...) 
{
  data <- data[which(!is.na(data))]
  if (proportion > 1 || proportion <= 0) 
    stop("proportion argument should be greater then zero and less than or equal to one")
  ntp <- round(proportion * length(data))
  if (ntp < 1) 
    stop("no valid measurements")
  if (ntp == 1) {
    warning(paste("One measurement, lambda = 1 returned"))
    return(list(estimate = 1, se = 999.99))
  }
  if (ntp < 10) 
    warning(paste("number of points is too small:", ntp))
  if (min(data) < 0) 
    stop("data argument has values <0")
  if (max(data) <= 1) {
    data <- qchisq(data, 1, lower.tail = FALSE)
  }
  if (filter) {
    data[which(abs(data) < 1e-08)] <- NA
  }
  data <- sort(data)
  ppoi <- stats::ppoints(data)
  ppoi <- sort(qchisq(ppoi, df = df, lower.tail = FALSE))
  data <- data[seq_len(ntp)]
  ppoi <- ppoi[seq_len(ntp)]
  out <- list()
  if (method == "regression") {
    s <- summary(stats::lm(data ~ 0 + ppoi))$coeff
    out$estimate <- s[1, 1]
    out$se <- s[1, 2]
  }
  else if (method == "median") {
    out$estimate <- median(data, na.rm = TRUE)/qchisq(0.5, 
                                                      df)
    out$se <- NA
  }
  else {
    stop("'method' should be either 'regression' or 'median'!")
  }
  if (plot) {
    lim <- c(0, max(data, ppoi, na.rm = TRUE))
    oldmargins <- graphics::par()$mar
    graphics::par(mar = oldmargins + 0.2)
    plot(ppoi, data, xlab = expression("Expected " ~ chi^2), 
         ylab = expression("Observed " ~ chi^2), ...)
    graphics::abline(a = 0, b = 1)
    graphics::abline(a = 0, b = out$estimate, col = "red")
    graphics::par(mar = oldmargins)
  }
  out
}

# HELPER - Load the pedigree

.loadPedi <- function(all.paths, pedigree.loc){

## Import the phenotype and sample info from external folder
file.copy(pedigree.loc, file.path(all.paths[1], "/PhenotypePedigreeAndVariables.txt"), overwrite = TRUE)
  
### Load the file
pedigree.table <- file.path(all.paths[1], "PhenotypePedigreeAndVariables.txt")
pedigree <- data.table::fread(pedigree.table, sep = "\t", header = TRUE)
  
return(pedigree)  
    
}

# HELPER - Linear mixed model for GWAS - considering pedigree

lmmCNV <- function(lo, all.paths, all.segs.gr, phen.info, method.m.test, model, 
                   probes.cnv.gr, assign.probe, correct.inflation, phenotypesSamX,
                   n.cor, verbose=FALSE, model.cnv.interactions="+ CNVx", run.lrr=FALSE, 
                   snp.gds=NULL, use.grm=NULL, use.pca=NULL, norm.lrr=TRUE, max.lrr, min.lrr,
                   lrr.to.use="standard", simulation=NULL, genofile=NULL,
                   list.simulation=NULL){
  
  if(!is.null(simulation) && is.null(genofile)){
    stop("In simulation gds needs to be provided as genofile parameter")
  }
  
  if(!is.null(simulation) && is.null(list.simulation)){
    stop("Simulation should provide a list.simulation")
  }
  
  #if(is.null(genofile)){
  #  genofile.back <- NULL
  #}else{
  #  genofile.back <-"other"
  #}
  
  if(is.null(simulation)){
    
  ### Map of the CNV probes
  cnv.gds <- file.path(all.paths[1], "CNV.gds")
  genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE, readonly = FALSE)
    
  ## Take phenotype directly form gds  
  phen.gds <- read.gdsn(index.gdsn(genofile, "phenotype")) #TEST
  
  ### Extract pedigree from the phen.info object
  ped <- as.data.frame(phen.info$pedigree)
  #ped <- ped[match(phen.gds$samplesPhen, ped$sample.id),]
  ped <- merge(ped, phen.gds, by.x="sample.id", by.y="samplesPhen", 
               all.x=FALSE, all.y=TRUE, suffixes = c("",".y"))
  
  ped <- ped[match(ped$sample.id, phen.gds$samplesPhen), ]
  ped <- ped[!duplicated(ped),]
  ped <- pedigree::add.Inds(ped)   
  ped$sire <- factor(ped$sire)
  ped$dam <- factor(ped$dam)
  
  
  }else{
  
  lop.sim <- lo
  pedigree.x <- list.simulation[[lop.sim]]
  phen.info$pedigree <- pedigree.x ## Attach simulated phenotypes
  
  ### Extract pedigree from the phen.info object
  ped <- as.data.frame(phen.info$pedigree)
  ped <- ped[!duplicated(ped),]
  ped <- pedigree::add.Inds(ped)   
  ped$sire <- factor(ped$sire)
  ped$dam <- factor(ped$dam)
  #}
      
  if (verbose) 
      message(paste("Simulation of phenotypes", lop.sim, "of", simulation))
    
  }
  
  if(!is.null(snp.gds)){
    snp.gds <- file.path(all.paths[1], "SNP.gds")
    genofile.snp <- SNPRelate::snpgdsOpen(snp.gds, allow.fork = TRUE, readonly = FALSE)
}

  if(is.null(use.grm)){
    p1 <- new("pedigree",
                 sire = as.integer(ped$sire),
                 dam = as.integer(ped$dam),
                 label = as.character(ped$sample.id))
    
    A <- getA(p1)
  }
  
  if("SNP.based" %in% use.grm){
    if(!is.null(gdsfmt::index.gdsn(genofile.snp, "GRM", silent=TRUE))){
      GRM <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile.snp, "GRM"))
    }
    #A <- Matrix::Matrix(GRM)
    #A <- GRM
    GRM.m <- GRM$grm
    colnames(GRM.m) <- GRM$sample.id
    rownames(GRM.m) <- GRM$sample.id
    A <- GRM.m
  }
  
  if("CNV.based" %in% use.grm){
    
    if(is.null(gdsfmt::index.gdsn(genofile, "GRM", silent=TRUE))){
    ## HELPER - GRM  
    cnvGRM <- function(genofile){
        ### change nodes to perform the PCA analysis
        genoBack <- (g <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "genotype")))  
        CNVgeno <- (g <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "CNVgenotypeSNPlike")))  
        
        n <- gdsfmt::add.gdsn(genofile, "genotype", CNVgeno, replace=TRUE)
        gdsfmt::read.gdsn(n)
        cor.matrix <- SNPRelate::snpgdsGRM(genofile, autosome.only=FALSE)
                                           #useMatrix=TRUE,
                                           #with.id=TRUE)
        add.gdsn(genofile, "GRM", cor.matrix, replace=TRUE)
        n <- gdsfmt::add.gdsn(genofile, "genotype", genoBack, replace=TRUE)
        gdsfmt::read.gdsn(n)
        return(cor.matrix)
      }
    cor.matrix <- cnvGRM(genofile) 
    add.gdsn(genofile, "GRM", cor.matrix, replace=TRUE)
    }
    
    if(!is.null(gdsfmt::index.gdsn(genofile, "GRM", silent=TRUE))){
      GRM <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "GRM"))
    }
    #A <- Matrix::Matrix(GRM)
    GRM.m <- GRM$grm
    colnames(GRM.m) <- GRM$sample.id
    rownames(GRM.m) <- GRM$sample.id
    A <- GRM.m
  }
  
  ## Produce the cnv.lrr-pedigree file
  if(run.lrr){
  if(lrr.to.use=="standard"){
  cnv.geno <- (g <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "LRR")))
  }
  if(lrr.to.use=="median"){
    if(is.null(gdsfmt::index.gdsn(genofile, "LRR.median", silent=TRUE))){
      .createSegLRR(genofile, unlist(all.segs.gr), probes.cnv.gr, method="median")
      }
  cnv.geno <- (g <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "LRR.median")))
  
  }
  if(lrr.to.use=="mean"){
    if(is.null(gdsfmt::index.gdsn(genofile, "LRR.mean", silent=TRUE))){
      .createSegLRR(genofile, unlist(all.segs.gr), probes.cnv.gr, method="mean")
    }
    cnv.geno <- (g <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "LRR.mean")))
  }
    
  if(norm.lrr){
    cnv.geno <- .normLRR(cnv.geno, max.lrr, min.lrr)  
  }
    
  cnv.geno[is.na(cnv.geno)] <- 0
  rownames(cnv.geno) <- paste0("LRR", seq_len(nrow(cnv.geno))) ## Put 'LRR' colnames
  cnv.geno.cn <- (g <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "CNVgenotype")))  
  rownames(cnv.geno.cn) <- paste0("CNV", seq_len(nrow(cnv.geno.cn))) ## Put 'CNV' colnames
  cnv.geno <- rbind(cnv.geno, cnv.geno.cn)
  
  }else{
  cnv.geno <- (g <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "CNVgenotype"))) 
  rownames(cnv.geno) <- paste0("CNV", seq_len(nrow(cnv.geno))) ## Put 'CNV' colnames
  }
  
  sample.id <- (g <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "sample.id")))
  
  colnames(cnv.geno) <- sample.id
  cnv.geno <- t(cnv.geno)
  cnv.geno <- as.data.frame(cnv.geno)
  cnv.geno$sample.id <- rownames(cnv.geno)
  #cnv.geno <- merge(ped, cnv.geno, by="sample.id", sort=TRUE)
  cnv.geno <- merge(cnv.geno, ped, by="sample.id", sort=TRUE) ## TEST
  
  ### Attach the PCA results
  if("CNV.based" %in% use.pca){
    if(!is.null(gdsfmt::index.gdsn(genofile, "PCA", silent=TRUE))){
      PCA <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "PCA"))
      ### merge with CNV genotypes
      #cnv.geno <- merge(cnv.geno, PCA, by="sample.id", sort=FALSE, all.x=TRUE, all.y=FALSE)
      cnv.geno <- merge(cnv.geno, PCA, by="sample.id", sort=TRUE, all.x=TRUE, all.y=FALSE)
    }else{
      stop("To create a CNV.based PCA analysis one needs to run with use.pca=NULL at least one time")
    }
    
  }
  
  if("SNP.based" %in% use.pca){
  if(!is.null(gdsfmt::index.gdsn(genofile.snp, "PCA", silent=TRUE))){
    PCA <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile.snp, "PCA"))
  }
    ### merge with CNV genotypes
    #cnv.geno <- merge(cnv.geno, PCA, by="sample.id", sort=FALSE, all.x=TRUE, all.y=FALSE)
    cnv.geno <- merge(cnv.geno, PCA, by="sample.id", sort=TRUE, all.x=TRUE, all.y=FALSE)
  }
  
  if(!is.null(snp.gds)){
  SNPRelate::snpgdsClose(genofile.snp)}
  
  ### Fit the model
  if (verbose)
  message("Fit the model - LMM")
  #rownames(cnv.geno) <- cnv.geno$sample.id ## TEST 
  #colnames(cnv.geno)[1] <- "ID" 
  #cnv.geno <- cnv.geno[match(rownames(A), cnv.geno$ID), ]
  ##TEST
  #if(TRUE){
    #rownames(A) <- as.char
  #}
  ## check the warning # https://github.com/variani/lme4qtl/issues/20
  mod <- lme4qtl::relmatLmer(model, cnv.geno, relmat = list(sample.id = A))
  m1 <- mod 
  
  ### Run for all the CNVs - TODO: implement in parallel
  if (verbose) 
    message("Fit each CNV segment in the model - LMM")
  
  ## Produce gvar file in parallel processing Identify the SO
    
  ### HELPER - update p-values for the fitted model  
  .updateModel <- function(loV, model.cnv.interactions, m1, cnv.geno){
    cod <- paste0("update(m1, . ~ . + ", model.cnv.interactions, ")") ##Vx
    cod <- gsub("x", loV, cod)
    m2 <- suppressWarnings(eval(parse(text = cod)))
   pvalues <-  suppressMessages(as.numeric(anova(m1, m2)$'Pr(>Chisq)'[2])) 
   return(pvalues) 
  }
    
    if (rappdirs:::get_os() == "unix" | rappdirs:::get_os() == "mac") {
      multicoreParam <- BiocParallel::MulticoreParam(workers = n.cor)
      all.pvalues <- suppressMessages(BiocParallel::bplapply(1:length(probes.cnv.gr), .updateModel, 
                                                      BPPARAM = multicoreParam, 
                                                      model.cnv.interactions=model.cnv.interactions, m1=m1,
                                                      cnv.geno=cnv.geno))
    }
    
    if (rappdirs:::get_os() == "win") {
      param <- BiocParallel::SnowParam(workers = n.cor, type = "SOCK")
      all.pvalues <- suppressMessages(BiocParallel::bplapply(1:length(probes.cnv.gr), .updateModel, 
                                                      BPPARAM = param,
                                                      model.cnv.interactions=model.cnv.interactions, m1=m1,
                                                      cnv.geno=cnv.geno))
    }
  
  all.pvalues <- unlist(all.pvalues)
  
  if (verbose) 
  message("Assign probes to CNV segments - LMM")
  
  ### Associate the p-values with the segments
  if(is.null(simulation)){
  SNPRelate::snpgdsClose(genofile)}

  if(is.null(simulation)){
   genofile <- NULL 
  }
  
  segs.pvalue.gr <- .assoPrCNV(all.paths=all.paths, all.segs.gr=all.segs.gr, phenotypesSamX=phenotypesSamX,
                               method.m.test=method.m.test, probes.cnv.gr=probes.cnv.gr, assign.probe=assign.probe, 
                               correct.inflation=correct.inflation, association.method="p.values", 
                               all.pvalues=all.pvalues, simulation=simulation, genofile=genofile)
  
  
   ### Run a CNV based PCA 
  if(is.null(simulation)){
  cnv.gds <- file.path(all.paths[1], "CNV.gds")
  genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE, readonly = FALSE)
  ### Add association test to the GDS
  gdsfmt::add.gdsn(genofile, name = "CNV.seg.pvalue", val = as.data.frame(segs.pvalue.gr), replace = TRUE)}
  if(!is.null(gdsfmt::index.gdsn(genofile, "CNVgenotypeSNPlike", silent=TRUE))){
  if(is.null(gdsfmt::index.gdsn(genofile, "PCA", silent=TRUE))){
    if(is.null(simulation)){
    SNPRelate::snpgdsClose(genofile)}
    PCAcnv(all.paths, segs.pvalue.gr, use.seg=FALSE)
  }else{
    if(is.null(simulation)){
    SNPRelate::snpgdsClose(genofile)}
  }
  }else{
    if(is.null(simulation)){
    SNPRelate::snpgdsClose(genofile)}
  }
  #SNPRelate::snpgdsClose(genofile)
  
  if(!is.null(simulation)){
    segs.pvalue.gr$simulation.list.lo <- lo
  }
    
    
  return(segs.pvalue.gr)
  
}

# HELPER - Normalize LRR values 

.normLRR <- function(dat, max.lrr, min.lrr){
    remove_outliers <- function(x, na.rm = TRUE, ...) {
      qnt <- quantile(x, probs=c(min.lrr, max.lrr), na.rm = na.rm, ...)
      H <- 1.5 * IQR(x, na.rm = na.rm)
      y <- x
      y[x < (qnt[1] - H)] <- NA
      y[x > (qnt[2] + H)] <- NA
      y
    }
    dat <- remove_outliers(dat)
    N <- length(dat)
    na.pos <- which(is.na(dat))
    if (length(na.pos) %in% c(0, N)) {
      return(dat)
    }
    non.na.pos <- which(!is.na(dat))
    intervals  <- findInterval(na.pos, non.na.pos,
                               all.inside = TRUE)
    left.pos   <- non.na.pos[pmax(1, intervals)]
    right.pos  <- non.na.pos[pmin(N, intervals+1)]
    left.dist  <- na.pos - left.pos
    right.dist <- right.pos - na.pos
    
    dat[na.pos] <- ifelse(left.dist <= right.dist,
                          dat[left.pos], dat[right.pos])
    return(dat)
  }
  
## HELPER Replace LRR values by the median in the segment

.createSegLRR <- function(genofile, segs.pvalue.gr, probes.cnv.gr, method){
  all.samples  <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "sample.id"))
  LRR  <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "LRR"))
  LRR.mod <- LRR
for (se in seq_along(segs.pvalue.gr)) {
  seqlevels(segs.pvalue.gr) <- seqlevels(probes.cnv.gr)
  probe.sel <- IRanges::subsetByOverlaps(probes.cnv.gr, 
                                         segs.pvalue.gr[se])
  ### Create the median LRR 
    for(sam in 1:length(all.samples)){
      seg.probes <- values(probe.sel)$snp.id
      if(method=="median"){
      LRR.mod[c(seg.probes),sam] <- rep(median(LRR[seg.probes,sam], na.rm = TRUE), length(seg.probes))
      message(paste0("Create median for LRR - sample ", sam, " CNV segment ", se))}
      else if(method=="mean"){
        LRR.mod[c(seg.probes),sam] <- rep(mean(LRR[seg.probes,sam], na.rm = TRUE), length(seg.probes))
        message(paste0("Create mean for LRR - sample ", sam, " CNV segment ", se))}
    }
}
  if(method=="median"){
  gdsfmt::add.gdsn(genofile, name = "LRR.median", val = LRR.mod, replace = TRUE)
  }else if(method=="mean"){
  gdsfmt::add.gdsn(genofile, name = "LRR.mean", val= LRR.mod, replace = TRUE)
    }
}

## HELPER Create CNV gds by origin (gain and loss separately)

.createOriginCNV <- function(all.paths, segs.pvalue.gr, freq.cn){
  cnv.gds <- file.path(all.paths[1], "CNV.gds")
  genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE, readonly = FALSE)
  cnv.geno <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "CNVgenotype"))
  
  #### Select only representative CNV probes
  map <- data.frame(snp.id = gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "snp.id")), 
                    chr = gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "snp.chromosome")), 
                    position = gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "snp.position")), 
                    probes = gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "snp.rs.id")), 
                    stringsAsFactors = FALSE)
  
  map$row.num <- seq(from=1, to=nrow(map))
  map.rep <- subset(map, probes %in% segs.pvalue.gr$NameProbe)
  
  cnv.geno <- cnv.geno[map.rep$row.num,]
  
  #### Create a new set of CNV genotypes 
  origin.cnv <- NULL
  snp.id <- NULL
  chr.all <- NULL
  position.all <- NULL
  
  for(rep in 1:nrow(cnv.geno)){
    cnv.geno.x <- cnv.geno[rep,]
    cnv.geno.x[cnv.geno.x>4] <- 4
    # Both, gain or loss?
    cnv.geno.x.fac <- factor(cnv.geno.x, levels=0:4)
    loss <- sum(table(cnv.geno.x.fac)[1:2]) ## Loss
    gain <- sum(table(cnv.geno.x.fac)[4:5]) ## Gain
    
    sample.id <- (g <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "sample.id")))
    min.sam <- length(sample.id)*freq.cn
    
    if(loss>=min.sam && gain>=min.sam){  ## both
      
      cnv.geno.x.loss <- cnv.geno.x
      cnv.geno.x.gain <- cnv.geno.x
      cnv.geno.x.loss[cnv.geno.x.loss>2] <- 2  
      cnv.geno.x.gain[cnv.geno.x.gain<2] <- 2  
      snp.id.loss <- paste0("Seg", rep, ".", 1)
      snp.id.gain <- paste0("Seg", rep, ".", 2)
      snp.id[[length(snp.id)+1]] <- snp.id.loss
      snp.id[[length(snp.id)+1]] <- snp.id.gain
      
      ## Get chr and position
      
      chr.all[[length(chr.all)+1]] <- map.rep$chr[rep] ## loss
      position.all[[length(position.all)+1]] <- map.rep$position[rep] ## loss
      chr.all[[length(chr.all)+1]] <- map.rep$chr[rep] ## gain
      position.all[[length(position.all)+1]] <- map.rep$position[rep] ## gain
      
      ### Transform in SNP-like genotypes (i.e. biallelic)
      cnv.geno.x.loss <- .replaceStringGeno(cnv.geno.x.loss, type="loss")
      cnv.geno.x.gain <- .replaceStringGeno(cnv.geno.x.gain, type="gain")
      
      origin.cnv <- rbind(origin.cnv,cnv.geno.x.loss)
      origin.cnv <- rbind(origin.cnv,cnv.geno.x.gain)
      #origin.cnv[[length(origin.cnv)+1]] <- cnv.geno.x.loss
      #origin.cnv[[length(origin.cnv)+1]] <- cnv.geno.x.gain
      
      
      }else if(loss>=min.sam && gain<min.sam){ ## loss
    
      cnv.geno.x.loss <- cnv.geno.x
      cnv.geno.x.loss[cnv.geno.x.loss>2] <- 2  
      #origin.cnv <- rbind(origin.cnv,cnv.geno.x.loss)
      snp.id.loss <- paste0("Seg", rep, ".", 1)
      snp.id[[length(snp.id)+1]] <- snp.id.loss
      
      ### Get chr and position
      
      chr.all[[length(chr.all)+1]] <- map.rep$chr[rep] ## loss
      position.all[[length(position.all)+1]] <- map.rep$position[rep] ## loss
      
      ### Transform in SNP-like genotypes (i.e. biallelic)
      cnv.geno.x.loss <- .replaceStringGeno(cnv.geno.x.loss, type="loss")
      
      origin.cnv <- rbind(origin.cnv,cnv.geno.x.loss)
      #origin.cnv[[length(origin.cnv)+1]] <- cnv.geno.x.loss
    
      }else if(loss<min.sam && gain>=min.sam){ ## gain
    
      cnv.geno.x.gain <- cnv.geno.x
      cnv.geno.x.gain[cnv.geno.x.gain<2] <- 2  
      #origin.cnv <- rbind(origin.cnv,cnv.geno.x.gain)
      snp.id.gain <- paste0("Seg", rep, ".", 2)
      snp.id[[length(snp.id)+1]] <- snp.id.gain
      
      ## Get chr and position
      
      chr.all[[length(chr.all)+1]] <- map.rep$chr[rep] ## loss
      position.all[[length(position.all)+1]] <- map.rep$position[rep] ## loss
      
      ### Transform in SNP-like genotypes (i.e. biallelic)
      cnv.geno.x.gain <- .replaceStringGeno(cnv.geno.x.gain, type="gain")
      
      origin.cnv <- rbind(origin.cnv,cnv.geno.x.gain)
      #origin.cnv[[length(origin.cnv)+1]] <- cnv.geno.x.gain
      
      }
  
  }
  SNPRelate::snpgdsClose(genofile)
  
  .createGdsOrigin(all.paths, list(snp.id, origin.cnv, sample.id, chr.all, position.all))
  
  return(list(snp.id, origin.cnv, sample.id, chr.all, position.all))
}
  
#origin.cnv <- .createOriginCNV(all.paths, segs.pvalue.gr, freq.cn)

##### HELPER - replace string

.replaceStringGeno <- function(cnv.geno.x, type){
  ### Replace
  cnv.geno.x <- gsub("0", "0n", cnv.geno.x)
  cnv.geno.x <- gsub("1", "1n", cnv.geno.x)
  cnv.geno.x <- gsub("2", "2n", cnv.geno.x)
  cnv.geno.x <- gsub("3", "3n", cnv.geno.x)
  cnv.geno.x <- gsub("4", "4n", cnv.geno.x)
  
  if(type=="loss"){
  cnv.geno.x <- gsub("0n", "0", cnv.geno.x)
  cnv.geno.x <- gsub("1n", "1", cnv.geno.x)
  cnv.geno.x <- gsub("2n", "2", cnv.geno.x)
  
  }else if(type=="gain"){
  cnv.geno.x <- gsub("2n", "0", cnv.geno.x)
  cnv.geno.x <- gsub("3n", "1", cnv.geno.x)
  cnv.geno.x <- gsub("4n", "2", cnv.geno.x)

  }else{
  stop("Not a valid option")
}
  return(cnv.geno.x)
}

#### HELPER - Create GDS with origin CNV genotypes

.createGdsOrigin <- function(all.paths, origin.cnv){
  
  cnv.gds <- file.path(all.paths[1], "CNV.gds")
  genofile <- SNPRelate::snpgdsOpen(cnv.gds, allow.fork = TRUE, readonly = FALSE)
  
  sample.id <- (g <- gdsfmt::read.gdsn(gdsfmt::index.gdsn(genofile, "sample.id")))
  SNPRelate::snpgdsClose(genofile)
  
  origin.cnv.m <- mapply(as.matrix(origin.cnv[[2]]), FUN=as.numeric)
  origin.cnv.m <- matrix(data=origin.cnv.m, ncol=ncol(as.matrix(origin.cnv[[2]])), nrow=nrow(as.matrix(origin.cnv[[2]])))
  
  # Create a GDS with chr and SNP names to numeric
  cnv.gds <- file.path(all.paths[1], "origin.CNV.gds")
  SNPRelate::snpgdsCreateGeno(cnv.gds, genmat = origin.cnv.m, sample.id = sample.id, 
                              snp.id = origin.cnv[[1]], 
                              snp.chromosome = origin.cnv[[4]], 
                              snp.position = origin.cnv[[5]])
  
}

#' Produce list simulation to be used in the cnvGWAS()
#' 
#' @param simulation Numeric or NULL. If numeric, simulated phenotypes will be used. The number
#' will define the number of permutation (i.e. if simualtion = 1000, the analysis will be performed
#' 1000 times with random phenotypes). The random phenotypes have the same standard deviation and mean
#' of the real phenotype defined in the model. 
#' @param model Linear mixed model to fit (without the CNV). Use \code{\link{formula}}
#' @param phen.info Returned by \code{\link{setupCnvGWAS}}
#' @export

produceRandomPheno <- function(simulation, model, phen.info){
  list.simulation <- vector("list", simulation)
  for(lop.sim in seq_len(simulation)){
    if(lop.sim==1){
        phen.name.in.model <- as.character(model[2])
        pedigree.x <- phen.info$pedigree
        pedigree.x.back <- pedigree.x
        phen.values <- pedigree.x[,which(colnames(pedigree.x) == phen.name.in.model)]
        sd.phen <- sd(phen.values, na.rm=TRUE)
        mean.phen <- mean(phen.values, na.rm=TRUE)
        num.na <- sum(is.na(phen.values))
        known.phen <- length(phen.values)-num.na
        na.to.bind <- rep(NA, num.na)}
      
      sim.phen <- rnorm(known.phen, mean=mean.phen, sd=sd.phen)
      sim.phen <- c(sim.phen, na.to.bind)
      sim.phen <- sample(sim.phen)
      pedigree.x[,which(colnames(pedigree.x) == phen.name.in.model)] <- sim.phen
   
      list.simulation[[lop.sim]] <- pedigree.x
    }
  return(list.simulation)
}

  